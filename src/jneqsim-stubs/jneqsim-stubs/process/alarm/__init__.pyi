import sys

if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.util
import jneqsim.process.logic
import jneqsim.process.measurementdevice
import jneqsim.process.processmodel
import typing

class AlarmActionHandler(java.io.Serializable):
    @staticmethod
    def activateLogic(
        string: typing.Union[java.lang.String, str],
        alarmLevel: "AlarmLevel",
        alarmEventType: "AlarmEventType",
        processLogic: jneqsim.process.logic.ProcessLogic,
    ) -> "AlarmActionHandler": ...
    @staticmethod
    def activateLogicOnHIHI(
        string: typing.Union[java.lang.String, str],
        processLogic: jneqsim.process.logic.ProcessLogic,
    ) -> "AlarmActionHandler": ...
    @staticmethod
    def activateLogicOnLOLO(
        string: typing.Union[java.lang.String, str],
        processLogic: jneqsim.process.logic.ProcessLogic,
    ) -> "AlarmActionHandler": ...
    @staticmethod
    def composite(
        list: java.util.List[typing.Union["AlarmActionHandler", typing.Callable]]
    ) -> "AlarmActionHandler": ...
    def getActionDescription(self) -> java.lang.String: ...
    def getPriority(self) -> int: ...
    def handle(self, alarmEvent: "AlarmEvent") -> bool: ...

class AlarmConfig(java.io.Serializable):
    @staticmethod
    def builder() -> "AlarmConfig.Builder": ...
    def getDeadband(self) -> float: ...
    def getDelay(self) -> float: ...
    def getHighHighLimit(self) -> float: ...
    def getHighLimit(self) -> float: ...
    def getLimit(self, alarmLevel: "AlarmLevel") -> float: ...
    def getLowLimit(self) -> float: ...
    def getLowLowLimit(self) -> float: ...
    def getUnit(self) -> java.lang.String: ...
    def hasLimit(self, alarmLevel: "AlarmLevel") -> bool: ...

    class Builder:
        def build(self) -> "AlarmConfig": ...
        def deadband(self, double: float) -> "AlarmConfig.Builder": ...
        def delay(self, double: float) -> "AlarmConfig.Builder": ...
        def highHighLimit(self, double: float) -> "AlarmConfig.Builder": ...
        def highLimit(self, double: float) -> "AlarmConfig.Builder": ...
        def lowLimit(self, double: float) -> "AlarmConfig.Builder": ...
        def lowLowLimit(self, double: float) -> "AlarmConfig.Builder": ...
        def unit(
            self, string: typing.Union[java.lang.String, str]
        ) -> "AlarmConfig.Builder": ...

class AlarmEvaluator:
    @staticmethod
    def evaluateAll(
        processAlarmManager: "ProcessAlarmManager",
        processSystem: jneqsim.process.processmodel.ProcessSystem,
        double: float,
        double2: float,
    ) -> java.util.List["AlarmEvent"]: ...
    @staticmethod
    def evaluateAndDisplay(
        processAlarmManager: "ProcessAlarmManager",
        list: java.util.List[
            jneqsim.process.measurementdevice.MeasurementDeviceInterface
        ],
        double: float,
        double2: float,
    ) -> java.util.List["AlarmEvent"]: ...
    @staticmethod
    def evaluateDevices(
        processAlarmManager: "ProcessAlarmManager",
        list: java.util.List[
            jneqsim.process.measurementdevice.MeasurementDeviceInterface
        ],
        double: float,
        double2: float,
    ) -> java.util.List["AlarmEvent"]: ...

class AlarmEvent(java.io.Serializable):
    @staticmethod
    def acknowledged(
        string: typing.Union[java.lang.String, str],
        alarmLevel: "AlarmLevel",
        double: float,
        double2: float,
    ) -> "AlarmEvent": ...
    @staticmethod
    def activated(
        string: typing.Union[java.lang.String, str],
        alarmLevel: "AlarmLevel",
        double: float,
        double2: float,
    ) -> "AlarmEvent": ...
    @staticmethod
    def cleared(
        string: typing.Union[java.lang.String, str],
        alarmLevel: "AlarmLevel",
        double: float,
        double2: float,
    ) -> "AlarmEvent": ...
    def getLevel(self) -> "AlarmLevel": ...
    def getSource(self) -> java.lang.String: ...
    def getTimestamp(self) -> float: ...
    def getType(self) -> "AlarmEventType": ...
    def getValue(self) -> float: ...
    def toString(self) -> java.lang.String: ...

class AlarmEventType(java.lang.Enum["AlarmEventType"]):
    ACTIVATED: typing.ClassVar["AlarmEventType"] = ...
    CLEARED: typing.ClassVar["AlarmEventType"] = ...
    ACKNOWLEDGED: typing.ClassVar["AlarmEventType"] = ...
    _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(
        class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]
    ) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: typing.Union[java.lang.String, str]) -> "AlarmEventType": ...
    @staticmethod
    def values() -> typing.MutableSequence["AlarmEventType"]: ...

class AlarmLevel(java.lang.Enum["AlarmLevel"], java.io.Serializable):
    LOLO: typing.ClassVar["AlarmLevel"] = ...
    LO: typing.ClassVar["AlarmLevel"] = ...
    HI: typing.ClassVar["AlarmLevel"] = ...
    HIHI: typing.ClassVar["AlarmLevel"] = ...
    def getDirection(self) -> "AlarmLevel.Direction": ...
    def getPriority(self) -> int: ...
    _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(
        class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]
    ) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: typing.Union[java.lang.String, str]) -> "AlarmLevel": ...
    @staticmethod
    def values() -> typing.MutableSequence["AlarmLevel"]: ...

    class Direction(java.lang.Enum["AlarmLevel.Direction"]):
        LOW: typing.ClassVar["AlarmLevel.Direction"] = ...
        HIGH: typing.ClassVar["AlarmLevel.Direction"] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: typing.Type[_valueOf_0__T],
            string: typing.Union[java.lang.String, str],
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(
            string: typing.Union[java.lang.String, str]
        ) -> "AlarmLevel.Direction": ...
        @staticmethod
        def values() -> typing.MutableSequence["AlarmLevel.Direction"]: ...

class AlarmReporter:
    @staticmethod
    def displayAlarmEvents(list: java.util.List[AlarmEvent]) -> None: ...
    @typing.overload
    @staticmethod
    def displayAlarmHistory(processAlarmManager: "ProcessAlarmManager") -> None: ...
    @typing.overload
    @staticmethod
    def displayAlarmHistory(
        processAlarmManager: "ProcessAlarmManager", int: int
    ) -> None: ...
    @staticmethod
    def displayAlarmStatistics(processAlarmManager: "ProcessAlarmManager") -> None: ...
    @staticmethod
    def displayAlarmStatus(
        processAlarmManager: "ProcessAlarmManager",
        string: typing.Union[java.lang.String, str],
    ) -> None: ...
    @staticmethod
    def formatAlarmEvent(alarmEvent: AlarmEvent) -> java.lang.String: ...
    @staticmethod
    def formatAlarmEventCompact(alarmEvent: AlarmEvent) -> java.lang.String: ...
    @staticmethod
    def printScenarioHeader(string: typing.Union[java.lang.String, str]) -> None: ...

class AlarmState(java.io.Serializable):
    def __init__(self): ...
    def acknowledge(
        self, string: typing.Union[java.lang.String, str], double: float
    ) -> AlarmEvent: ...
    def evaluate(
        self,
        alarmConfig: AlarmConfig,
        double: float,
        double2: float,
        double3: float,
        string: typing.Union[java.lang.String, str],
    ) -> java.util.List[AlarmEvent]: ...
    def getActiveLevel(self) -> AlarmLevel: ...
    def getLastUpdateTime(self) -> float: ...
    def getLastValue(self) -> float: ...
    def isAcknowledged(self) -> bool: ...
    def isActive(self) -> bool: ...
    def reset(self) -> None: ...
    def snapshot(
        self, string: typing.Union[java.lang.String, str]
    ) -> "AlarmStatusSnapshot": ...

class AlarmStatusSnapshot(java.io.Serializable):
    def __init__(
        self,
        string: typing.Union[java.lang.String, str],
        alarmLevel: AlarmLevel,
        boolean: bool,
        double: float,
        double2: float,
    ): ...
    def getLevel(self) -> AlarmLevel: ...
    def getSource(self) -> java.lang.String: ...
    def getTimestamp(self) -> float: ...
    def getValue(self) -> float: ...
    def isAcknowledged(self) -> bool: ...

class ProcessAlarmManager(java.io.Serializable):
    def __init__(self): ...
    def acknowledgeAll(self, double: float) -> java.util.List[AlarmEvent]: ...
    def applyFrom(
        self,
        processAlarmManager: "ProcessAlarmManager",
        list: java.util.List[
            jneqsim.process.measurementdevice.MeasurementDeviceInterface
        ],
    ) -> None: ...
    def clearHistory(self) -> None: ...
    def equals(self, object: typing.Any) -> bool: ...
    def evaluateMeasurement(
        self,
        measurementDeviceInterface: jneqsim.process.measurementdevice.MeasurementDeviceInterface,
        double: float,
        double2: float,
        double3: float,
    ) -> java.util.List[AlarmEvent]: ...
    def getActionHandlers(self) -> java.util.List[AlarmActionHandler]: ...
    def getActiveAlarms(self) -> java.util.List[AlarmStatusSnapshot]: ...
    def getHistory(self) -> java.util.List[AlarmEvent]: ...
    def hashCode(self) -> int: ...
    def register(
        self,
        measurementDeviceInterface: jneqsim.process.measurementdevice.MeasurementDeviceInterface,
    ) -> None: ...
    def registerActionHandler(
        self, alarmActionHandler: typing.Union[AlarmActionHandler, typing.Callable]
    ) -> None: ...
    def registerAll(
        self,
        list: java.util.List[
            jneqsim.process.measurementdevice.MeasurementDeviceInterface
        ],
    ) -> None: ...
    def removeActionHandler(
        self, alarmActionHandler: typing.Union[AlarmActionHandler, typing.Callable]
    ) -> None: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.process.alarm")``.

    AlarmActionHandler: typing.Type[AlarmActionHandler]
    AlarmConfig: typing.Type[AlarmConfig]
    AlarmEvaluator: typing.Type[AlarmEvaluator]
    AlarmEvent: typing.Type[AlarmEvent]
    AlarmEventType: typing.Type[AlarmEventType]
    AlarmLevel: typing.Type[AlarmLevel]
    AlarmReporter: typing.Type[AlarmReporter]
    AlarmState: typing.Type[AlarmState]
    AlarmStatusSnapshot: typing.Type[AlarmStatusSnapshot]
    ProcessAlarmManager: typing.Type[ProcessAlarmManager]
