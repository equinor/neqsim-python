
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import datetime
import java.io
import java.lang
import java.time
import java.util
import jpype
import jneqsim.process.equipment
import jneqsim.process.processmodel
import typing



class ControllerDataExchange(java.io.Serializable):
    def __init__(self, processLinkedMPC: 'ProcessLinkedMPC'): ...
    def execute(self) -> bool: ...
    def getExecutionCount(self) -> int: ...
    def getExecutionMessage(self) -> java.lang.String: ...
    def getExecutionStatus(self) -> 'ControllerDataExchange.ExecutionStatus': ...
    def getLastExecution(self) -> java.time.Instant: ...
    def getLastInputUpdate(self) -> java.time.Instant: ...
    def getMvTargets(self) -> typing.MutableSequence[float]: ...
    def getOutputs(self) -> 'ControllerDataExchange.ControllerOutput': ...
    def getSetpoints(self) -> typing.MutableSequence[float]: ...
    def getStatus(self) -> java.util.Map[java.lang.String, typing.Any]: ...
    def getVariableNames(self) -> java.util.Map[java.lang.String, java.util.List[java.lang.String]]: ...
    def updateInputs(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], doubleArray3: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def updateInputsWithQuality(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], doubleArray3: typing.Union[typing.List[float], jpype.JArray], qualityStatusArray: typing.Union[typing.List['ControllerDataExchange.QualityStatus'], jpype.JArray], qualityStatusArray2: typing.Union[typing.List['ControllerDataExchange.QualityStatus'], jpype.JArray], qualityStatusArray3: typing.Union[typing.List['ControllerDataExchange.QualityStatus'], jpype.JArray]) -> None: ...
    def updateLimits(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def updateSetpoints(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    class ControllerOutput(java.io.Serializable):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], executionStatus: 'ControllerDataExchange.ExecutionStatus', string: typing.Union[java.lang.String, str], instant: typing.Union[java.time.Instant, datetime.datetime]): ...
        def getCvPredictions(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
        def getMessage(self) -> java.lang.String: ...
        def getMvTargets(self) -> typing.MutableSequence[float]: ...
        def getStatus(self) -> 'ControllerDataExchange.ExecutionStatus': ...
        def getTimestamp(self) -> java.time.Instant: ...
        def isSuccess(self) -> bool: ...
    class ExecutionStatus(java.lang.Enum['ControllerDataExchange.ExecutionStatus']):
        READY: typing.ClassVar['ControllerDataExchange.ExecutionStatus'] = ...
        SUCCESS: typing.ClassVar['ControllerDataExchange.ExecutionStatus'] = ...
        WARNING: typing.ClassVar['ControllerDataExchange.ExecutionStatus'] = ...
        FAILED: typing.ClassVar['ControllerDataExchange.ExecutionStatus'] = ...
        MODEL_STALE: typing.ClassVar['ControllerDataExchange.ExecutionStatus'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'ControllerDataExchange.ExecutionStatus': ...
        @staticmethod
        def values() -> typing.MutableSequence['ControllerDataExchange.ExecutionStatus']: ...
    class QualityStatus(java.lang.Enum['ControllerDataExchange.QualityStatus']):
        GOOD: typing.ClassVar['ControllerDataExchange.QualityStatus'] = ...
        BAD: typing.ClassVar['ControllerDataExchange.QualityStatus'] = ...
        UNCERTAIN: typing.ClassVar['ControllerDataExchange.QualityStatus'] = ...
        MANUAL: typing.ClassVar['ControllerDataExchange.QualityStatus'] = ...
        CLAMPED: typing.ClassVar['ControllerDataExchange.QualityStatus'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'ControllerDataExchange.QualityStatus': ...
        @staticmethod
        def values() -> typing.MutableSequence['ControllerDataExchange.QualityStatus']: ...

class IndustrialMPCExporter(java.io.Serializable):
    def __init__(self, processLinkedMPC: 'ProcessLinkedMPC'): ...
    def createDataExchange(self) -> ControllerDataExchange: ...
    def createSoftSensorExporter(self) -> 'SoftSensorExporter': ...
    def exportComprehensiveConfiguration(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def exportGainMatrix(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def exportObjectStructure(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def exportStepResponseCSV(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def exportStepResponseModel(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def exportTransferFunctions(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def exportVariableConfiguration(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def setApplicationName(self, string: typing.Union[java.lang.String, str]) -> 'IndustrialMPCExporter': ...
    def setDefaultTimeConstant(self, double: float) -> 'IndustrialMPCExporter': ...
    def setNumStepCoefficients(self, int: int) -> 'IndustrialMPCExporter': ...
    def setTagPrefix(self, string: typing.Union[java.lang.String, str]) -> 'IndustrialMPCExporter': ...

class LinearizationResult(java.io.Serializable):
    @typing.overload
    def __init__(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], doubleArray2: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], doubleArray3: typing.Union[typing.List[float], jpype.JArray], doubleArray4: typing.Union[typing.List[float], jpype.JArray], doubleArray5: typing.Union[typing.List[float], jpype.JArray], stringArray: typing.Union[typing.List[java.lang.String], jpype.JArray], stringArray2: typing.Union[typing.List[java.lang.String], jpype.JArray], stringArray3: typing.Union[typing.List[java.lang.String], jpype.JArray], double6: float, long: int): ...
    @typing.overload
    def __init__(self, string: typing.Union[java.lang.String, str], long: int): ...
    def formatGainMatrix(self) -> java.lang.String: ...
    def getComputationTimeMs(self) -> int: ...
    def getCvNames(self) -> typing.MutableSequence[java.lang.String]: ...
    def getCvOperatingPoint(self) -> typing.MutableSequence[float]: ...
    def getDisturbanceGain(self, int: int, int2: int) -> float: ...
    def getDisturbanceGainMatrix(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def getDvNames(self) -> typing.MutableSequence[java.lang.String]: ...
    def getDvOperatingPoint(self) -> typing.MutableSequence[float]: ...
    def getErrorMessage(self) -> java.lang.String: ...
    @typing.overload
    def getGain(self, int: int, int2: int) -> float: ...
    @typing.overload
    def getGain(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> float: ...
    def getGainMatrix(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def getGainsForCV(self, int: int) -> typing.MutableSequence[float]: ...
    def getGainsForMV(self, int: int) -> typing.MutableSequence[float]: ...
    def getMvNames(self) -> typing.MutableSequence[java.lang.String]: ...
    def getMvOperatingPoint(self) -> typing.MutableSequence[float]: ...
    def getNumCV(self) -> int: ...
    def getNumDV(self) -> int: ...
    def getNumMV(self) -> int: ...
    def getPerturbationSize(self) -> float: ...
    def isSuccessful(self) -> bool: ...
    def toString(self) -> java.lang.String: ...

class MPCVariable(java.io.Serializable):
    def getCurrentValue(self) -> float: ...
    def getDescription(self) -> java.lang.String: ...
    def getEquipment(self) -> jneqsim.process.equipment.ProcessEquipmentInterface: ...
    def getMaxValue(self) -> float: ...
    def getMinValue(self) -> float: ...
    def getName(self) -> java.lang.String: ...
    def getPropertyName(self) -> java.lang.String: ...
    def getType(self) -> 'MPCVariable.MPCVariableType': ...
    def getUnit(self) -> java.lang.String: ...
    def readValue(self) -> float: ...
    def setBounds(self, double: float, double2: float) -> 'MPCVariable': ...
    def setCurrentValue(self, double: float) -> None: ...
    def setDescription(self, string: typing.Union[java.lang.String, str]) -> 'MPCVariable': ...
    def setEquipment(self, processEquipmentInterface: jneqsim.process.equipment.ProcessEquipmentInterface) -> 'MPCVariable': ...
    def setPropertyName(self, string: typing.Union[java.lang.String, str]) -> 'MPCVariable': ...
    def setUnit(self, string: typing.Union[java.lang.String, str]) -> 'MPCVariable': ...
    def toString(self) -> java.lang.String: ...
    class MPCVariableType(java.lang.Enum['MPCVariable.MPCVariableType']):
        MANIPULATED: typing.ClassVar['MPCVariable.MPCVariableType'] = ...
        CONTROLLED: typing.ClassVar['MPCVariable.MPCVariableType'] = ...
        DISTURBANCE: typing.ClassVar['MPCVariable.MPCVariableType'] = ...
        STATE: typing.ClassVar['MPCVariable.MPCVariableType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'MPCVariable.MPCVariableType': ...
        @staticmethod
        def values() -> typing.MutableSequence['MPCVariable.MPCVariableType']: ...

class NonlinearPredictor(java.io.Serializable):
    def __init__(self, processSystem: jneqsim.process.processmodel.ProcessSystem): ...
    def addCV(self, controlledVariable: 'ControlledVariable') -> 'NonlinearPredictor': ...
    def addMV(self, manipulatedVariable: 'ManipulatedVariable') -> 'NonlinearPredictor': ...
    def clear(self) -> 'NonlinearPredictor': ...
    def getPredictionHorizon(self) -> int: ...
    def getSampleTimeSeconds(self) -> float: ...
    def predict(self, mVTrajectory: 'NonlinearPredictor.MVTrajectory') -> 'NonlinearPredictor.PredictionResult': ...
    def predictConstant(self, *double: float) -> 'NonlinearPredictor.PredictionResult': ...
    def setCloneProcess(self, boolean: bool) -> 'NonlinearPredictor': ...
    def setPredictionHorizon(self, int: int) -> 'NonlinearPredictor': ...
    def setSampleTime(self, double: float) -> 'NonlinearPredictor': ...
    class MVTrajectory(java.io.Serializable):
        def __init__(self): ...
        def addMove(self, string: typing.Union[java.lang.String, str], double: float) -> 'NonlinearPredictor.MVTrajectory': ...
        def clear(self) -> 'NonlinearPredictor.MVTrajectory': ...
        def getLength(self, string: typing.Union[java.lang.String, str]) -> int: ...
        def getValue(self, string: typing.Union[java.lang.String, str], int: int) -> float: ...
        def setMoves(self, string: typing.Union[java.lang.String, str], doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> 'NonlinearPredictor.MVTrajectory': ...
    class PredictionResult(java.io.Serializable):
        def __init__(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], doubleArray2: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], doubleArray3: typing.Union[typing.List[float], jpype.JArray], stringArray: typing.Union[typing.List[java.lang.String], jpype.JArray], stringArray2: typing.Union[typing.List[java.lang.String], jpype.JArray], double4: float): ...
        def getCvNames(self) -> typing.MutableSequence[java.lang.String]: ...
        def getFinalValue(self, string: typing.Union[java.lang.String, str]) -> float: ...
        def getHorizon(self) -> int: ...
        def getISE(self, string: typing.Union[java.lang.String, str], double: float) -> float: ...
        def getMVTrajectory(self, string: typing.Union[java.lang.String, str]) -> typing.MutableSequence[float]: ...
        def getMvNames(self) -> typing.MutableSequence[java.lang.String]: ...
        def getSampleTime(self) -> float: ...
        def getTime(self) -> typing.MutableSequence[float]: ...
        @typing.overload
        def getTrajectory(self, int: int) -> typing.MutableSequence[float]: ...
        @typing.overload
        def getTrajectory(self, string: typing.Union[java.lang.String, str]) -> typing.MutableSequence[float]: ...
        def toString(self) -> java.lang.String: ...

class ProcessDerivativeCalculator:
    def __init__(self, processSystem: jneqsim.process.processmodel.ProcessSystem): ...
    @typing.overload
    def addInputVariable(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> 'ProcessDerivativeCalculator': ...
    @typing.overload
    def addInputVariable(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], double: float) -> 'ProcessDerivativeCalculator': ...
    def addOutputVariable(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> 'ProcessDerivativeCalculator': ...
    def calculateHessian(self, string: typing.Union[java.lang.String, str]) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def calculateJacobian(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def clearInputVariables(self) -> 'ProcessDerivativeCalculator': ...
    def clearOutputVariables(self) -> 'ProcessDerivativeCalculator': ...
    def exportJacobianToCSV(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def exportJacobianToJSON(self) -> java.lang.String: ...
    def getBaseInputValues(self) -> typing.MutableSequence[float]: ...
    def getBaseOutputValues(self) -> typing.MutableSequence[float]: ...
    def getDerivative(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> float: ...
    def getGradient(self, string: typing.Union[java.lang.String, str]) -> typing.MutableSequence[float]: ...
    def getInputVariableNames(self) -> java.util.List[java.lang.String]: ...
    def getOutputVariableNames(self) -> java.util.List[java.lang.String]: ...
    def setMethod(self, derivativeMethod: 'ProcessDerivativeCalculator.DerivativeMethod') -> 'ProcessDerivativeCalculator': ...
    def setParallel(self, boolean: bool, int: int) -> 'ProcessDerivativeCalculator': ...
    def setRelativeStepSize(self, double: float) -> 'ProcessDerivativeCalculator': ...
    class DerivativeMethod(java.lang.Enum['ProcessDerivativeCalculator.DerivativeMethod']):
        FORWARD_DIFFERENCE: typing.ClassVar['ProcessDerivativeCalculator.DerivativeMethod'] = ...
        CENTRAL_DIFFERENCE: typing.ClassVar['ProcessDerivativeCalculator.DerivativeMethod'] = ...
        CENTRAL_DIFFERENCE_SECOND_ORDER: typing.ClassVar['ProcessDerivativeCalculator.DerivativeMethod'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'ProcessDerivativeCalculator.DerivativeMethod': ...
        @staticmethod
        def values() -> typing.MutableSequence['ProcessDerivativeCalculator.DerivativeMethod']: ...
    class DerivativeResult:
        value: float = ...
        errorEstimate: float = ...
        stepSize: float = ...
        isValid: bool = ...
        errorMessage: java.lang.String = ...
        @typing.overload
        def __init__(self, double: float, double2: float): ...
        @typing.overload
        def __init__(self, string: typing.Union[java.lang.String, str]): ...
    class VariableSpec:
        path: java.lang.String = ...
        unit: java.lang.String = ...
        customStepSize: float = ...
        type: 'ProcessDerivativeCalculator.VariableType' = ...
        def __init__(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]): ...
    class VariableType(java.lang.Enum['ProcessDerivativeCalculator.VariableType']):
        PRESSURE: typing.ClassVar['ProcessDerivativeCalculator.VariableType'] = ...
        TEMPERATURE: typing.ClassVar['ProcessDerivativeCalculator.VariableType'] = ...
        FLOW_RATE: typing.ClassVar['ProcessDerivativeCalculator.VariableType'] = ...
        COMPOSITION: typing.ClassVar['ProcessDerivativeCalculator.VariableType'] = ...
        LEVEL: typing.ClassVar['ProcessDerivativeCalculator.VariableType'] = ...
        GENERAL: typing.ClassVar['ProcessDerivativeCalculator.VariableType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'ProcessDerivativeCalculator.VariableType': ...
        @staticmethod
        def values() -> typing.MutableSequence['ProcessDerivativeCalculator.VariableType']: ...

class ProcessLinearizer:
    def __init__(self, processSystem: jneqsim.process.processmodel.ProcessSystem): ...
    def addCV(self, controlledVariable: 'ControlledVariable') -> 'ProcessLinearizer': ...
    def addDV(self, disturbanceVariable: 'DisturbanceVariable') -> 'ProcessLinearizer': ...
    def addMV(self, manipulatedVariable: 'ManipulatedVariable') -> 'ProcessLinearizer': ...
    def clear(self) -> 'ProcessLinearizer': ...
    def getControlledVariables(self) -> java.util.List['ControlledVariable']: ...
    def getDisturbanceVariables(self) -> java.util.List['DisturbanceVariable']: ...
    def getManipulatedVariables(self) -> java.util.List['ManipulatedVariable']: ...
    def isApproximatelyLinear(self, double: float, double2: float, double3: float) -> bool: ...
    @typing.overload
    def linearize(self) -> LinearizationResult: ...
    @typing.overload
    def linearize(self, double: float) -> LinearizationResult: ...
    def linearizeMultiplePoints(self, int: int, double: float) -> java.util.List[LinearizationResult]: ...
    def setDefaultPerturbationSize(self, double: float) -> 'ProcessLinearizer': ...
    def setMinimumAbsolutePerturbation(self, double: float) -> 'ProcessLinearizer': ...
    def setUseCentralDifferences(self, boolean: bool) -> 'ProcessLinearizer': ...

class ProcessLinkedMPC(java.io.Serializable):
    def __init__(self, string: typing.Union[java.lang.String, str], processSystem: jneqsim.process.processmodel.ProcessSystem): ...
    def addCV(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], double: float) -> 'ControlledVariable': ...
    def addCVZone(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], double: float, double2: float) -> 'ControlledVariable': ...
    def addDV(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> 'DisturbanceVariable': ...
    @typing.overload
    def addMV(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], double: float, double2: float) -> 'ManipulatedVariable': ...
    @typing.overload
    def addMV(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], double: float, double2: float, double3: float) -> 'ManipulatedVariable': ...
    @typing.overload
    def addSVR(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> 'StateVariable': ...
    @typing.overload
    def addSVR(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], string3: typing.Union[java.lang.String, str]) -> 'StateVariable': ...
    def applyMoves(self) -> None: ...
    def calculate(self) -> typing.MutableSequence[float]: ...
    def createDataExchange(self) -> ControllerDataExchange: ...
    def createIndustrialExporter(self) -> IndustrialMPCExporter: ...
    def createSubrModlExporter(self) -> 'SubrModlExporter': ...
    def exportModel(self) -> 'StateSpaceExporter': ...
    def getConfigurationSummary(self) -> java.lang.String: ...
    def getControlHorizon(self) -> int: ...
    def getControlledVariables(self) -> java.util.List['ControlledVariable']: ...
    def getCurrentCVs(self) -> typing.MutableSequence[float]: ...
    def getCurrentMVs(self) -> typing.MutableSequence[float]: ...
    def getDisturbanceVariables(self) -> java.util.List['DisturbanceVariable']: ...
    def getLastMoves(self) -> typing.MutableSequence[float]: ...
    def getLinearizationResult(self) -> LinearizationResult: ...
    def getManipulatedVariables(self) -> java.util.List['ManipulatedVariable']: ...
    def getName(self) -> java.lang.String: ...
    def getPredictionHorizon(self) -> int: ...
    def getProcessSystem(self) -> jneqsim.process.processmodel.ProcessSystem: ...
    def getSampleTime(self) -> float: ...
    def getStateVariables(self) -> java.util.List['StateVariable']: ...
    def identifyModel(self, double: float) -> None: ...
    def isModelIdentified(self) -> bool: ...
    def runProcess(self) -> None: ...
    def setConstraint(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], double: float, double2: float) -> None: ...
    def setControlHorizon(self, int: int) -> None: ...
    def setErrorWeight(self, string: typing.Union[java.lang.String, str], double: float) -> None: ...
    def setModelUpdateInterval(self, int: int) -> None: ...
    def setMoveSuppressionWeight(self, string: typing.Union[java.lang.String, str], double: float) -> None: ...
    def setPredictionHorizon(self, int: int) -> None: ...
    def setSampleTime(self, double: float) -> None: ...
    def setSetpoint(self, string: typing.Union[java.lang.String, str], double: float) -> None: ...
    def setUseNonlinearPrediction(self, boolean: bool) -> None: ...
    def step(self) -> typing.MutableSequence[float]: ...
    def toString(self) -> java.lang.String: ...
    def updateDisturbances(self) -> None: ...
    def updateMeasurements(self) -> None: ...
    def updateModel(self) -> None: ...

class ProcessVariableAccessor:
    def __init__(self, processSystem: jneqsim.process.processmodel.ProcessSystem): ...
    @typing.overload
    def getValue(self, string: typing.Union[java.lang.String, str]) -> float: ...
    @typing.overload
    def getValue(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> float: ...
    def isValidPath(self, string: typing.Union[java.lang.String, str]) -> bool: ...
    @typing.overload
    def setValue(self, string: typing.Union[java.lang.String, str], double: float) -> None: ...
    @typing.overload
    def setValue(self, string: typing.Union[java.lang.String, str], double: float, string2: typing.Union[java.lang.String, str]) -> None: ...

class SoftSensorExporter(java.io.Serializable):
    def __init__(self, processSystem: jneqsim.process.processmodel.ProcessSystem): ...
    def addCompositionEstimator(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], string3: typing.Union[java.lang.String, str]) -> 'SoftSensorExporter': ...
    def addCompressibilitySensor(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> 'SoftSensorExporter': ...
    def addCustomSensor(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], sensorType: 'SoftSensorExporter.SensorType', string3: typing.Union[java.lang.String, str]) -> 'SoftSensorExporter.SoftSensorDefinition': ...
    def addDensitySensor(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], string3: typing.Union[java.lang.String, str]) -> 'SoftSensorExporter': ...
    def addHeatCapacitySensor(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], string3: typing.Union[java.lang.String, str]) -> 'SoftSensorExporter': ...
    def addMolecularWeightSensor(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> 'SoftSensorExporter': ...
    def addPhaseFractionSensor(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> 'SoftSensorExporter': ...
    def addViscositySensor(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], string3: typing.Union[java.lang.String, str]) -> 'SoftSensorExporter': ...
    def clear(self) -> 'SoftSensorExporter': ...
    def exportCVTFormat(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def exportConfiguration(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def getSensors(self) -> java.util.List['SoftSensorExporter.SoftSensorDefinition']: ...
    def setApplicationName(self, string: typing.Union[java.lang.String, str]) -> 'SoftSensorExporter': ...
    def setTagPrefix(self, string: typing.Union[java.lang.String, str]) -> 'SoftSensorExporter': ...
    class SensorType(java.lang.Enum['SoftSensorExporter.SensorType']):
        DENSITY: typing.ClassVar['SoftSensorExporter.SensorType'] = ...
        VISCOSITY: typing.ClassVar['SoftSensorExporter.SensorType'] = ...
        PHASE_FRACTION: typing.ClassVar['SoftSensorExporter.SensorType'] = ...
        COMPOSITION: typing.ClassVar['SoftSensorExporter.SensorType'] = ...
        MOLECULAR_WEIGHT: typing.ClassVar['SoftSensorExporter.SensorType'] = ...
        COMPRESSIBILITY: typing.ClassVar['SoftSensorExporter.SensorType'] = ...
        HEAT_CAPACITY: typing.ClassVar['SoftSensorExporter.SensorType'] = ...
        ENTHALPY: typing.ClassVar['SoftSensorExporter.SensorType'] = ...
        ENTROPY: typing.ClassVar['SoftSensorExporter.SensorType'] = ...
        CUSTOM: typing.ClassVar['SoftSensorExporter.SensorType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'SoftSensorExporter.SensorType': ...
        @staticmethod
        def values() -> typing.MutableSequence['SoftSensorExporter.SensorType']: ...
    class SoftSensorDefinition(java.io.Serializable):
        def __init__(self, string: typing.Union[java.lang.String, str], sensorType: 'SoftSensorExporter.SensorType'): ...
        def addInput(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> 'SoftSensorExporter.SoftSensorDefinition': ...
        def addParameter(self, string: typing.Union[java.lang.String, str], double: float) -> 'SoftSensorExporter.SoftSensorDefinition': ...
        def getComponentName(self) -> java.lang.String: ...
        def getDescription(self) -> java.lang.String: ...
        def getEquipmentName(self) -> java.lang.String: ...
        def getInputs(self) -> java.util.Map[java.lang.String, java.lang.String]: ...
        def getName(self) -> java.lang.String: ...
        def getOutputUnit(self) -> java.lang.String: ...
        def getParameters(self) -> java.util.Map[java.lang.String, float]: ...
        def getSensorType(self) -> 'SoftSensorExporter.SensorType': ...
        def getUpdateRateSeconds(self) -> float: ...
        def setComponentName(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setDescription(self, string: typing.Union[java.lang.String, str]) -> 'SoftSensorExporter.SoftSensorDefinition': ...
        def setEquipmentName(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setOutputUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setUpdateRateSeconds(self, double: float) -> 'SoftSensorExporter.SoftSensorDefinition': ...
        def toMap(self, string: typing.Union[java.lang.String, str]) -> java.util.Map[java.lang.String, typing.Any]: ...

class StateSpaceExporter(java.io.Serializable):
    @typing.overload
    def __init__(self, linearizationResult: LinearizationResult): ...
    @typing.overload
    def __init__(self, stepResponseMatrix: 'StepResponseGenerator.StepResponseMatrix'): ...
    def exportCSV(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def exportJSON(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def exportMATLAB(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def exportStepCoefficients(self, string: typing.Union[java.lang.String, str], int: int) -> None: ...
    def getStateSpaceModel(self) -> 'StateSpaceExporter.StateSpaceModel': ...
    def setStepResponseMatrix(self, stepResponseMatrix: 'StepResponseGenerator.StepResponseMatrix') -> 'StateSpaceExporter': ...
    def toDiscreteStateSpace(self, double: float) -> 'StateSpaceExporter.StateSpaceModel': ...
    class StateSpaceModel(java.io.Serializable):
        def __init__(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], doubleArray2: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], doubleArray3: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], doubleArray4: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], double5: float, stringArray: typing.Union[typing.List[java.lang.String], jpype.JArray], stringArray2: typing.Union[typing.List[java.lang.String], jpype.JArray]): ...
        def getA(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
        def getB(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
        def getC(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
        def getD(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
        def getDominantTimeConstant(self, int: int) -> float: ...
        def getInputNames(self) -> typing.MutableSequence[java.lang.String]: ...
        def getNumInputs(self) -> int: ...
        def getNumOutputs(self) -> int: ...
        def getNumStates(self) -> int: ...
        def getOutput(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray]) -> typing.MutableSequence[float]: ...
        def getOutputNames(self) -> typing.MutableSequence[java.lang.String]: ...
        def getSampleTime(self) -> float: ...
        def getSteadyStateGain(self, int: int, int2: int) -> float: ...
        def stepState(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray]) -> typing.MutableSequence[float]: ...
        def toMap(self) -> java.util.Map[java.lang.String, typing.Any]: ...
        def toString(self) -> java.lang.String: ...

class StepResponse(java.io.Serializable):
    def __init__(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], double3: float, double4: float, double5: float, string3: typing.Union[java.lang.String, str], string4: typing.Union[java.lang.String, str]): ...
    def convolve(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> typing.MutableSequence[float]: ...
    def fitFOPDT(self) -> 'StepResponse': ...
    def getBaselineValue(self) -> float: ...
    def getCvName(self) -> java.lang.String: ...
    def getDeadTime(self) -> float: ...
    def getFitError(self) -> float: ...
    def getGain(self) -> float: ...
    def getMvName(self) -> java.lang.String: ...
    def getNormalizedResponse(self) -> typing.MutableSequence[float]: ...
    def getNumSamples(self) -> int: ...
    def getResponse(self) -> typing.MutableSequence[float]: ...
    def getRiseTime(self) -> float: ...
    def getSampleTime(self) -> float: ...
    def getSettlingTime(self) -> float: ...
    def getStepCoefficients(self, int: int) -> typing.MutableSequence[float]: ...
    def getStepSize(self) -> float: ...
    def getTime(self) -> typing.MutableSequence[float]: ...
    def getTimeConstant(self) -> float: ...
    def hasInverseResponse(self) -> bool: ...
    def toString(self) -> java.lang.String: ...

class StepResponseGenerator(java.io.Serializable):
    def __init__(self, processSystem: jneqsim.process.processmodel.ProcessSystem): ...
    def addCV(self, controlledVariable: 'ControlledVariable') -> 'StepResponseGenerator': ...
    def addMV(self, manipulatedVariable: 'ManipulatedVariable') -> 'StepResponseGenerator': ...
    def clear(self) -> 'StepResponseGenerator': ...
    def generateAllResponses(self) -> 'StepResponseGenerator.StepResponseMatrix': ...
    def getSampleIntervalSeconds(self) -> float: ...
    def getSettlingTimeSeconds(self) -> float: ...
    def getStepSizeFraction(self) -> float: ...
    def runStepTest(self, manipulatedVariable: 'ManipulatedVariable') -> java.util.List[StepResponse]: ...
    def setBidirectionalTest(self, boolean: bool) -> 'StepResponseGenerator': ...
    def setPositiveStep(self, boolean: bool) -> 'StepResponseGenerator': ...
    def setSampleInterval(self, double: float, string: typing.Union[java.lang.String, str]) -> 'StepResponseGenerator': ...
    def setSettlingTime(self, double: float, string: typing.Union[java.lang.String, str]) -> 'StepResponseGenerator': ...
    def setStepSize(self, double: float) -> 'StepResponseGenerator': ...
    class StepResponseMatrix(java.io.Serializable):
        def __init__(self, map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], typing.Union[java.util.Map[typing.Union[java.lang.String, str], StepResponse], typing.Mapping[typing.Union[java.lang.String, str], StepResponse]]], typing.Mapping[typing.Union[java.lang.String, str], typing.Union[java.util.Map[typing.Union[java.lang.String, str], StepResponse], typing.Mapping[typing.Union[java.lang.String, str], StepResponse]]]], stringArray: typing.Union[typing.List[java.lang.String], jpype.JArray], stringArray2: typing.Union[typing.List[java.lang.String], jpype.JArray]): ...
        def get(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> StepResponse: ...
        def getCvNames(self) -> typing.MutableSequence[java.lang.String]: ...
        def getDeadTimeMatrix(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
        def getGainMatrix(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
        def getMvNames(self) -> typing.MutableSequence[java.lang.String]: ...
        def getTimeConstantMatrix(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
        def toCSV(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...

class SubrModlExporter(java.io.Serializable):
    def __init__(self, processSystem: jneqsim.process.processmodel.ProcessSystem): ...
    def addIndexEntry(self, string: typing.Union[java.lang.String, str]) -> 'SubrModlExporter': ...
    @typing.overload
    def addParameter(self, string: typing.Union[java.lang.String, str], double: float, string2: typing.Union[java.lang.String, str]) -> 'SubrModlExporter': ...
    @typing.overload
    def addParameter(self, string: typing.Union[java.lang.String, str], double: float, string2: typing.Union[java.lang.String, str], string3: typing.Union[java.lang.String, str]) -> 'SubrModlExporter': ...
    def addStateVariable(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], string3: typing.Union[java.lang.String, str], double: float) -> 'SubrModlExporter': ...
    def addSubrXvr(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], string3: typing.Union[java.lang.String, str], double: float) -> 'SubrModlExporter': ...
    def exportConfiguration(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def exportIndexTable(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def exportJSON(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def exportMPCConfiguration(self, string: typing.Union[java.lang.String, str], boolean: bool) -> None: ...
    def getIndexTable(self) -> java.util.List[java.lang.String]: ...
    def getParameters(self) -> java.util.List['SubrModlExporter.ModelParameter']: ...
    def getStateVariables(self) -> java.util.List['SubrModlExporter.StateVariable']: ...
    def getSubrXvrs(self) -> java.util.List['SubrModlExporter.SubrXvr']: ...
    def populateFromMPC(self, processLinkedMPC: ProcessLinkedMPC) -> 'SubrModlExporter': ...
    def setApplicationName(self, string: typing.Union[java.lang.String, str]) -> 'SubrModlExporter': ...
    def setModelName(self, string: typing.Union[java.lang.String, str]) -> 'SubrModlExporter': ...
    def setSampleTime(self, double: float) -> 'SubrModlExporter': ...
    class ModelParameter(java.io.Serializable):
        def __init__(self, string: typing.Union[java.lang.String, str], double: float, string2: typing.Union[java.lang.String, str], string3: typing.Union[java.lang.String, str]): ...
        def getDescription(self) -> java.lang.String: ...
        def getName(self) -> java.lang.String: ...
        def getUnit(self) -> java.lang.String: ...
        def getValue(self) -> float: ...
    class StateVariable(java.io.Serializable):
        def __init__(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], string3: typing.Union[java.lang.String, str], double: float): ...
        def getDescription(self) -> java.lang.String: ...
        def getDtaIx(self) -> java.lang.String: ...
        def getMeasValue(self) -> float: ...
        def getModelValue(self) -> float: ...
        def getName(self) -> java.lang.String: ...
        def isMeasured(self) -> bool: ...
        def setMeasValue(self, double: float) -> 'SubrModlExporter.StateVariable': ...
    class SubrXvr(java.io.Serializable):
        def __init__(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], string3: typing.Union[java.lang.String, str], double: float): ...
        def getDtaIx(self) -> java.lang.String: ...
        def getInit(self) -> float: ...
        def getName(self) -> java.lang.String: ...
        def getText1(self) -> java.lang.String: ...
        def getText2(self) -> java.lang.String: ...
        def getUnit(self) -> java.lang.String: ...
        def setInit(self, double: float) -> 'SubrModlExporter.SubrXvr': ...
        def setUnit(self, string: typing.Union[java.lang.String, str]) -> 'SubrModlExporter.SubrXvr': ...

class ControlledVariable(MPCVariable):
    @typing.overload
    def __init__(self, string: typing.Union[java.lang.String, str]): ...
    @typing.overload
    def __init__(self, string: typing.Union[java.lang.String, str], processEquipmentInterface: jneqsim.process.equipment.ProcessEquipmentInterface, string2: typing.Union[java.lang.String, str]): ...
    @typing.overload
    def __init__(self, string: typing.Union[java.lang.String, str], processEquipmentInterface: jneqsim.process.equipment.ProcessEquipmentInterface, string2: typing.Union[java.lang.String, str], string3: typing.Union[java.lang.String, str]): ...
    def getEffectiveSetpoint(self) -> float: ...
    def getHardMax(self) -> float: ...
    def getHardMin(self) -> float: ...
    def getPredictedValue(self) -> float: ...
    def getSetpoint(self) -> float: ...
    def getSoftConstraintPenalty(self) -> float: ...
    def getSoftMax(self) -> float: ...
    def getSoftMin(self) -> float: ...
    def getSoftViolation(self) -> float: ...
    def getTrackingError(self) -> float: ...
    def getType(self) -> MPCVariable.MPCVariableType: ...
    def getWeight(self) -> float: ...
    def getZoneLower(self) -> float: ...
    def getZoneUpper(self) -> float: ...
    def isWithinZone(self) -> bool: ...
    def isZoneControl(self) -> bool: ...
    def readValue(self) -> float: ...
    def setBounds(self, double: float, double2: float) -> 'ControlledVariable': ...
    def setEquipment(self, processEquipmentInterface: jneqsim.process.equipment.ProcessEquipmentInterface) -> 'ControlledVariable': ...
    def setHardConstraints(self, double: float, double2: float) -> 'ControlledVariable': ...
    def setPredictedValue(self, double: float) -> None: ...
    def setPropertyName(self, string: typing.Union[java.lang.String, str]) -> 'ControlledVariable': ...
    def setSetpoint(self, double: float) -> 'ControlledVariable': ...
    def setSoftConstraintPenalty(self, double: float) -> 'ControlledVariable': ...
    def setSoftConstraints(self, double: float, double2: float) -> 'ControlledVariable': ...
    def setUnit(self, string: typing.Union[java.lang.String, str]) -> 'ControlledVariable': ...
    def setWeight(self, double: float) -> 'ControlledVariable': ...
    def setZone(self, double: float, double2: float) -> 'ControlledVariable': ...

class DisturbanceVariable(MPCVariable):
    @typing.overload
    def __init__(self, string: typing.Union[java.lang.String, str]): ...
    @typing.overload
    def __init__(self, string: typing.Union[java.lang.String, str], processEquipmentInterface: jneqsim.process.equipment.ProcessEquipmentInterface, string2: typing.Union[java.lang.String, str]): ...
    @typing.overload
    def __init__(self, string: typing.Union[java.lang.String, str], processEquipmentInterface: jneqsim.process.equipment.ProcessEquipmentInterface, string2: typing.Union[java.lang.String, str], string3: typing.Union[java.lang.String, str]): ...
    def getCvSensitivity(self) -> typing.MutableSequence[float]: ...
    def getExpectedCvChange(self, int: int) -> float: ...
    def getExpectedCvChangeFromPrediction(self, int: int) -> float: ...
    def getPredictedValue(self) -> float: ...
    def getPredictionHorizon(self) -> float: ...
    def getPreviousValue(self) -> float: ...
    def getRateOfChange(self) -> float: ...
    def getType(self) -> MPCVariable.MPCVariableType: ...
    def isMeasured(self) -> bool: ...
    def readValue(self) -> float: ...
    def setBounds(self, double: float, double2: float) -> 'DisturbanceVariable': ...
    def setCurrentValue(self, double: float) -> None: ...
    def setCvSensitivity(self, *double: float) -> 'DisturbanceVariable': ...
    def setEquipment(self, processEquipmentInterface: jneqsim.process.equipment.ProcessEquipmentInterface) -> 'DisturbanceVariable': ...
    def setMeasured(self, boolean: bool) -> 'DisturbanceVariable': ...
    def setPrediction(self, double: float, double2: float) -> 'DisturbanceVariable': ...
    def setPropertyName(self, string: typing.Union[java.lang.String, str]) -> 'DisturbanceVariable': ...
    def setUnit(self, string: typing.Union[java.lang.String, str]) -> 'DisturbanceVariable': ...
    def update(self, double: float) -> 'DisturbanceVariable': ...

class ManipulatedVariable(MPCVariable):
    @typing.overload
    def __init__(self, string: typing.Union[java.lang.String, str]): ...
    @typing.overload
    def __init__(self, string: typing.Union[java.lang.String, str], processEquipmentInterface: jneqsim.process.equipment.ProcessEquipmentInterface, string2: typing.Union[java.lang.String, str]): ...
    @typing.overload
    def __init__(self, string: typing.Union[java.lang.String, str], processEquipmentInterface: jneqsim.process.equipment.ProcessEquipmentInterface, string2: typing.Union[java.lang.String, str], string3: typing.Union[java.lang.String, str]): ...
    def calculateCost(self) -> float: ...
    def getCost(self) -> float: ...
    def getInitialValue(self) -> float: ...
    def getMaxRateOfChange(self) -> float: ...
    def getMinRateOfChange(self) -> float: ...
    def getMoveWeight(self) -> float: ...
    def getPreferredValue(self) -> float: ...
    def getPreferredWeight(self) -> float: ...
    def getType(self) -> MPCVariable.MPCVariableType: ...
    def isFeasible(self, double: float) -> bool: ...
    def readValue(self) -> float: ...
    def setBounds(self, double: float, double2: float) -> 'ManipulatedVariable': ...
    def setCost(self, double: float) -> 'ManipulatedVariable': ...
    def setEquipment(self, processEquipmentInterface: jneqsim.process.equipment.ProcessEquipmentInterface) -> 'ManipulatedVariable': ...
    def setInitialValue(self, double: float) -> 'ManipulatedVariable': ...
    def setMoveWeight(self, double: float) -> 'ManipulatedVariable': ...
    def setPreferredValue(self, double: float) -> 'ManipulatedVariable': ...
    def setPreferredWeight(self, double: float) -> 'ManipulatedVariable': ...
    def setPropertyName(self, string: typing.Union[java.lang.String, str]) -> 'ManipulatedVariable': ...
    def setRateLimit(self, double: float, double2: float) -> 'ManipulatedVariable': ...
    def setUnit(self, string: typing.Union[java.lang.String, str]) -> 'ManipulatedVariable': ...
    def writeValue(self, double: float) -> None: ...

class StateVariable(MPCVariable, java.io.Serializable):
    def __init__(self, string: typing.Union[java.lang.String, str], processEquipmentInterface: jneqsim.process.equipment.ProcessEquipmentInterface, string2: typing.Union[java.lang.String, str]): ...
    def clearMeasurement(self) -> None: ...
    def getBias(self) -> float: ...
    def getBiasTfilt(self) -> float: ...
    def getBiasTpred(self) -> float: ...
    def getCorrectedValue(self) -> float: ...
    def getCurrentValue(self) -> float: ...
    def getDtaIx(self) -> java.lang.String: ...
    def getMeasuredValue(self) -> float: ...
    def getModelValue(self) -> float: ...
    def getType(self) -> MPCVariable.MPCVariableType: ...
    def hasMeasurement(self) -> bool: ...
    def isUpdateFromMeasurement(self) -> bool: ...
    def predictBias(self, double: float, double2: float, double3: float) -> float: ...
    def readFromProcess(self) -> float: ...
    def readValue(self) -> float: ...
    def setBiasTfilt(self, double: float) -> None: ...
    def setBiasTpred(self, double: float) -> None: ...
    def setDtaIx(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def setMeasuredValue(self, double: float) -> None: ...
    def setModelValue(self, double: float) -> None: ...
    def setUpdateFromMeasurement(self, boolean: bool) -> None: ...
    def toString(self) -> java.lang.String: ...
    def update(self, double: float) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.process.mpc")``.

    ControlledVariable: typing.Type[ControlledVariable]
    ControllerDataExchange: typing.Type[ControllerDataExchange]
    DisturbanceVariable: typing.Type[DisturbanceVariable]
    IndustrialMPCExporter: typing.Type[IndustrialMPCExporter]
    LinearizationResult: typing.Type[LinearizationResult]
    MPCVariable: typing.Type[MPCVariable]
    ManipulatedVariable: typing.Type[ManipulatedVariable]
    NonlinearPredictor: typing.Type[NonlinearPredictor]
    ProcessDerivativeCalculator: typing.Type[ProcessDerivativeCalculator]
    ProcessLinearizer: typing.Type[ProcessLinearizer]
    ProcessLinkedMPC: typing.Type[ProcessLinkedMPC]
    ProcessVariableAccessor: typing.Type[ProcessVariableAccessor]
    SoftSensorExporter: typing.Type[SoftSensorExporter]
    StateSpaceExporter: typing.Type[StateSpaceExporter]
    StateVariable: typing.Type[StateVariable]
    StepResponse: typing.Type[StepResponse]
    StepResponseGenerator: typing.Type[StepResponseGenerator]
    SubrModlExporter: typing.Type[SubrModlExporter]
