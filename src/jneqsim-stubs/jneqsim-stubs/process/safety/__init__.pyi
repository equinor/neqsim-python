
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.util
import java.util.function
import jneqsim.process.equipment
import jneqsim.process.equipment.flare
import jneqsim.process.processmodel
import jneqsim.process.safety.dto
import jneqsim.process.safety.envelope
import jneqsim.process.safety.release
import jneqsim.process.safety.risk
import jneqsim.process.safety.scenario
import typing



class BoundaryConditions(java.io.Serializable):
    DEFAULT_AMBIENT_TEMPERATURE: typing.ClassVar[float] = ...
    DEFAULT_WIND_SPEED: typing.ClassVar[float] = ...
    DEFAULT_RELATIVE_HUMIDITY: typing.ClassVar[float] = ...
    DEFAULT_ATMOSPHERIC_PRESSURE: typing.ClassVar[float] = ...
    @staticmethod
    def builder() -> 'BoundaryConditions.Builder': ...
    @staticmethod
    def defaultConditions() -> 'BoundaryConditions': ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def getAmbientTemperature(self) -> float: ...
    @typing.overload
    def getAmbientTemperature(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getAtmosphericPressure(self) -> float: ...
    def getAtmosphericPressureBar(self) -> float: ...
    def getPasquillStabilityClass(self) -> str: ...
    def getRelativeHumidity(self) -> float: ...
    @typing.overload
    def getSeaWaterTemperature(self) -> float: ...
    @typing.overload
    def getSeaWaterTemperature(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getSolarRadiation(self) -> float: ...
    def getSurfaceRoughness(self) -> float: ...
    def getWindDirection(self) -> float: ...
    def getWindSpeed(self) -> float: ...
    @staticmethod
    def gulfOfMexico() -> 'BoundaryConditions': ...
    def hashCode(self) -> int: ...
    def isOffshore(self) -> bool: ...
    @staticmethod
    def northSeaSummer() -> 'BoundaryConditions': ...
    @staticmethod
    def northSeaWinter() -> 'BoundaryConditions': ...
    @staticmethod
    def onshoreIndustrial() -> 'BoundaryConditions': ...
    def toString(self) -> java.lang.String: ...
    class Builder:
        def __init__(self): ...
        @typing.overload
        def ambientTemperature(self, double: float) -> 'BoundaryConditions.Builder': ...
        @typing.overload
        def ambientTemperature(self, double: float, string: typing.Union[java.lang.String, str]) -> 'BoundaryConditions.Builder': ...
        def atmosphericPressure(self, double: float) -> 'BoundaryConditions.Builder': ...
        def build(self) -> 'BoundaryConditions': ...
        def isOffshore(self, boolean: bool) -> 'BoundaryConditions.Builder': ...
        def pasquillStabilityClass(self, char: str) -> 'BoundaryConditions.Builder': ...
        def relativeHumidity(self, double: float) -> 'BoundaryConditions.Builder': ...
        def seaWaterTemperature(self, double: float) -> 'BoundaryConditions.Builder': ...
        def solarRadiation(self, double: float) -> 'BoundaryConditions.Builder': ...
        def surfaceRoughness(self, double: float) -> 'BoundaryConditions.Builder': ...
        def windDirection(self, double: float) -> 'BoundaryConditions.Builder': ...
        def windSpeed(self, double: float) -> 'BoundaryConditions.Builder': ...

class DisposalNetwork(java.io.Serializable):
    def __init__(self): ...
    def evaluate(self, list: java.util.List['ProcessSafetyLoadCase']) -> jneqsim.process.safety.dto.DisposalNetworkSummaryDTO: ...
    def mapSourceToDisposal(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> None: ...
    def registerDisposalUnit(self, flare: jneqsim.process.equipment.flare.Flare) -> None: ...

class InitiatingEvent(java.lang.Enum['InitiatingEvent']):
    ESD: typing.ClassVar['InitiatingEvent'] = ...
    PSV_LIFT: typing.ClassVar['InitiatingEvent'] = ...
    RUPTURE: typing.ClassVar['InitiatingEvent'] = ...
    LEAK_SMALL: typing.ClassVar['InitiatingEvent'] = ...
    LEAK_MEDIUM: typing.ClassVar['InitiatingEvent'] = ...
    LEAK_LARGE: typing.ClassVar['InitiatingEvent'] = ...
    FULL_BORE_RUPTURE: typing.ClassVar['InitiatingEvent'] = ...
    BLOCKED_OUTLET: typing.ClassVar['InitiatingEvent'] = ...
    UTILITY_LOSS: typing.ClassVar['InitiatingEvent'] = ...
    FIRE_EXPOSURE: typing.ClassVar['InitiatingEvent'] = ...
    RUNAWAY_REACTION: typing.ClassVar['InitiatingEvent'] = ...
    THERMAL_EXPANSION: typing.ClassVar['InitiatingEvent'] = ...
    TUBE_RUPTURE: typing.ClassVar['InitiatingEvent'] = ...
    CONTROL_VALVE_FAILURE: typing.ClassVar['InitiatingEvent'] = ...
    COMPRESSOR_SURGE: typing.ClassVar['InitiatingEvent'] = ...
    LOSS_OF_CONTAINMENT: typing.ClassVar['InitiatingEvent'] = ...
    MANUAL_INTERVENTION: typing.ClassVar['InitiatingEvent'] = ...
    def getDescription(self) -> java.lang.String: ...
    def getDisplayName(self) -> java.lang.String: ...
    def getTypicalHoleDiameter(self) -> typing.MutableSequence[float]: ...
    def isReleaseEvent(self) -> bool: ...
    def requiresFireAnalysis(self) -> bool: ...
    def toString(self) -> java.lang.String: ...
    def triggersDepressurization(self) -> bool: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: typing.Union[java.lang.String, str]) -> 'InitiatingEvent': ...
    @staticmethod
    def values() -> typing.MutableSequence['InitiatingEvent']: ...

class ProcessSafetyAnalysisSummary(java.io.Serializable):
    def __init__(self, string: typing.Union[java.lang.String, str], set: java.util.Set[typing.Union[java.lang.String, str]], string2: typing.Union[java.lang.String, str], map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], typing.Union[java.lang.String, str]], typing.Mapping[typing.Union[java.lang.String, str], typing.Union[java.lang.String, str]]], map2: typing.Union[java.util.Map[typing.Union[java.lang.String, str], 'ProcessSafetyAnalysisSummary.UnitKpiSnapshot'], typing.Mapping[typing.Union[java.lang.String, str], 'ProcessSafetyAnalysisSummary.UnitKpiSnapshot']]): ...
    def getAffectedUnits(self) -> java.util.Set[java.lang.String]: ...
    def getConditionMessages(self) -> java.util.Map[java.lang.String, java.lang.String]: ...
    def getConditionMonitorReport(self) -> java.lang.String: ...
    def getScenarioName(self) -> java.lang.String: ...
    def getUnitKpis(self) -> java.util.Map[java.lang.String, 'ProcessSafetyAnalysisSummary.UnitKpiSnapshot']: ...
    class UnitKpiSnapshot(java.io.Serializable):
        def __init__(self, double: float, double2: float, double3: float): ...
        def getMassBalance(self) -> float: ...
        def getPressure(self) -> float: ...
        def getTemperature(self) -> float: ...

class ProcessSafetyAnalyzer(java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, processSystem: jneqsim.process.processmodel.ProcessSystem): ...
    @typing.overload
    def __init__(self, processSystem: jneqsim.process.processmodel.ProcessSystem, processSafetyResultRepository: typing.Union['ProcessSafetyResultRepository', typing.Callable]): ...
    def addLoadCase(self, processSafetyLoadCase: 'ProcessSafetyLoadCase') -> None: ...
    @typing.overload
    def analyze(self, collection: typing.Union[java.util.Collection['ProcessSafetyScenario'], typing.Sequence['ProcessSafetyScenario'], typing.Set['ProcessSafetyScenario']]) -> java.util.List[ProcessSafetyAnalysisSummary]: ...
    @typing.overload
    def analyze(self, processSafetyScenario: 'ProcessSafetyScenario') -> ProcessSafetyAnalysisSummary: ...
    @typing.overload
    def analyze(self) -> jneqsim.process.safety.dto.DisposalNetworkSummaryDTO: ...
    def getLoadCases(self) -> java.util.List['ProcessSafetyLoadCase']: ...
    def mapSourceToDisposal(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> None: ...
    def registerDisposalUnit(self, flare: jneqsim.process.equipment.flare.Flare) -> None: ...

class ProcessSafetyLoadCase(java.io.Serializable):
    def __init__(self, string: typing.Union[java.lang.String, str]): ...
    def addReliefSource(self, string: typing.Union[java.lang.String, str], reliefSourceLoad: 'ProcessSafetyLoadCase.ReliefSourceLoad') -> None: ...
    def getName(self) -> java.lang.String: ...
    def getReliefLoads(self) -> java.util.Map[java.lang.String, 'ProcessSafetyLoadCase.ReliefSourceLoad']: ...
    class ReliefSourceLoad(java.io.Serializable):
        def __init__(self, double: float, double2: float, double3: float): ...
        def getHeatDutyW(self) -> float: ...
        def getMassRateKgS(self) -> float: ...
        def getMolarRateMoleS(self) -> float: ...

class ProcessSafetyResultRepository:
    def findAll(self) -> java.util.List[ProcessSafetyAnalysisSummary]: ...
    def save(self, processSafetyAnalysisSummary: ProcessSafetyAnalysisSummary) -> None: ...

class ProcessSafetyScenario(java.io.Serializable):
    def applyTo(self, processSystem: jneqsim.process.processmodel.ProcessSystem) -> None: ...
    @staticmethod
    def builder(string: typing.Union[java.lang.String, str]) -> 'ProcessSafetyScenario.Builder': ...
    def getBlockedOutletUnits(self) -> java.util.List[java.lang.String]: ...
    def getControllerSetPointOverrides(self) -> java.util.Map[java.lang.String, float]: ...
    def getCustomManipulators(self) -> java.util.Map[java.lang.String, java.util.function.Consumer[jneqsim.process.equipment.ProcessEquipmentInterface]]: ...
    def getName(self) -> java.lang.String: ...
    def getTargetUnits(self) -> java.util.Set[java.lang.String]: ...
    def getUtilityLossUnits(self) -> java.util.List[java.lang.String]: ...
    class Builder:
        def blockOutlet(self, string: typing.Union[java.lang.String, str]) -> 'ProcessSafetyScenario.Builder': ...
        def blockOutlets(self, collection: typing.Union[java.util.Collection[typing.Union[java.lang.String, str]], typing.Sequence[typing.Union[java.lang.String, str]], typing.Set[typing.Union[java.lang.String, str]]]) -> 'ProcessSafetyScenario.Builder': ...
        def build(self) -> 'ProcessSafetyScenario': ...
        def controllerSetPoint(self, string: typing.Union[java.lang.String, str], double: float) -> 'ProcessSafetyScenario.Builder': ...
        def customManipulator(self, string: typing.Union[java.lang.String, str], consumer: typing.Union[java.util.function.Consumer[jneqsim.process.equipment.ProcessEquipmentInterface], typing.Callable[[jneqsim.process.equipment.ProcessEquipmentInterface], None]]) -> 'ProcessSafetyScenario.Builder': ...
        def utilityLoss(self, string: typing.Union[java.lang.String, str]) -> 'ProcessSafetyScenario.Builder': ...
        def utilityLosses(self, collection: typing.Union[java.util.Collection[typing.Union[java.lang.String, str]], typing.Sequence[typing.Union[java.lang.String, str]], typing.Set[typing.Union[java.lang.String, str]]]) -> 'ProcessSafetyScenario.Builder': ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.process.safety")``.

    BoundaryConditions: typing.Type[BoundaryConditions]
    DisposalNetwork: typing.Type[DisposalNetwork]
    InitiatingEvent: typing.Type[InitiatingEvent]
    ProcessSafetyAnalysisSummary: typing.Type[ProcessSafetyAnalysisSummary]
    ProcessSafetyAnalyzer: typing.Type[ProcessSafetyAnalyzer]
    ProcessSafetyLoadCase: typing.Type[ProcessSafetyLoadCase]
    ProcessSafetyResultRepository: typing.Type[ProcessSafetyResultRepository]
    ProcessSafetyScenario: typing.Type[ProcessSafetyScenario]
    dto: jneqsim.process.safety.dto.__module_protocol__
    envelope: jneqsim.process.safety.envelope.__module_protocol__
    release: jneqsim.process.safety.release.__module_protocol__
    risk: jneqsim.process.safety.risk.__module_protocol__
    scenario: jneqsim.process.safety.scenario.__module_protocol__
