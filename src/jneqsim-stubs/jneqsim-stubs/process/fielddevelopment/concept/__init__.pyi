import sys

if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.util
import typing

class FieldConcept(java.io.Serializable):
    @staticmethod
    def builder(
        string: typing.Union[java.lang.String, str]
    ) -> "FieldConcept.Builder": ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def gasTieback(string: typing.Union[java.lang.String, str]) -> "FieldConcept": ...
    @typing.overload
    @staticmethod
    def gasTieback(
        string: typing.Union[java.lang.String, str],
        double: float,
        int: int,
        double2: float,
    ) -> "FieldConcept": ...
    def getDescription(self) -> java.lang.String: ...
    def getId(self) -> java.lang.String: ...
    def getInfrastructure(self) -> "InfrastructureInput": ...
    def getName(self) -> java.lang.String: ...
    def getProductionRateUnit(self) -> java.lang.String: ...
    def getReservoir(self) -> "ReservoirInput": ...
    def getSummary(self) -> java.lang.String: ...
    def getTiebackLength(self) -> float: ...
    def getTotalProductionRate(self) -> float: ...
    def getWaterDepth(self) -> float: ...
    def getWells(self) -> "WellsInput": ...
    def hasWaterInjection(self) -> bool: ...
    def hashCode(self) -> int: ...
    def isSubseaTieback(self) -> bool: ...
    def needsCO2Removal(self) -> bool: ...
    def needsDehydration(self) -> bool: ...
    def needsH2SRemoval(self) -> bool: ...
    def needsH2STreatment(self) -> bool: ...
    @typing.overload
    @staticmethod
    def oilDevelopment(
        string: typing.Union[java.lang.String, str]
    ) -> "FieldConcept": ...
    @typing.overload
    @staticmethod
    def oilDevelopment(
        string: typing.Union[java.lang.String, str],
        int: int,
        double: float,
        double2: float,
    ) -> "FieldConcept": ...
    def toString(self) -> java.lang.String: ...

    class Builder:
        def build(self) -> "FieldConcept": ...
        def description(
            self, string: typing.Union[java.lang.String, str]
        ) -> "FieldConcept.Builder": ...
        def id(
            self, string: typing.Union[java.lang.String, str]
        ) -> "FieldConcept.Builder": ...
        def infrastructure(
            self, infrastructureInput: "InfrastructureInput"
        ) -> "FieldConcept.Builder": ...
        def reservoir(
            self, reservoirInput: "ReservoirInput"
        ) -> "FieldConcept.Builder": ...
        def wells(self, wellsInput: "WellsInput") -> "FieldConcept.Builder": ...

class InfrastructureInput(java.io.Serializable):
    @staticmethod
    def builder() -> "InfrastructureInput.Builder": ...
    def getAmbientAirTemperature(self) -> float: ...
    def getAmbientSeaTemperature(self) -> float: ...
    def getEstimatedSeabedTemperature(self) -> float: ...
    def getExportPipelineDiameter(self) -> float: ...
    def getExportPipelineLength(self) -> float: ...
    def getExportPressure(self) -> float: ...
    def getExportType(self) -> "InfrastructureInput.ExportType": ...
    def getHostCapacityAvailable(self) -> float: ...
    def getPowerSupply(self) -> "InfrastructureInput.PowerSupply": ...
    def getProcessingLocation(self) -> "InfrastructureInput.ProcessingLocation": ...
    def getTiebackLength(self) -> float: ...
    def getTiebackLengthKm(self) -> float: ...
    def getWaterDepth(self) -> float: ...
    def getWaterDepthM(self) -> float: ...
    def hasElectricHeating(self) -> bool: ...
    def isDeepWater(self) -> bool: ...
    def isElectrified(self) -> bool: ...
    def isInsulatedFlowline(self) -> bool: ...
    def isLongTieback(self) -> bool: ...
    @staticmethod
    def subseaTieback() -> "InfrastructureInput.Builder": ...
    def toString(self) -> java.lang.String: ...

    class Builder:
        def ambientTemperatures(
            self, double: float, double2: float
        ) -> "InfrastructureInput.Builder": ...
        def build(self) -> "InfrastructureInput": ...
        def electricHeating(self, boolean: bool) -> "InfrastructureInput.Builder": ...
        def exportPipeline(
            self, double: float, double2: float
        ) -> "InfrastructureInput.Builder": ...
        def exportPressure(self, double: float) -> "InfrastructureInput.Builder": ...
        def exportType(
            self, exportType: "InfrastructureInput.ExportType"
        ) -> "InfrastructureInput.Builder": ...
        def hostCapacityAvailable(
            self, double: float
        ) -> "InfrastructureInput.Builder": ...
        def insulatedFlowline(self, boolean: bool) -> "InfrastructureInput.Builder": ...
        def powerSupply(
            self, powerSupply: "InfrastructureInput.PowerSupply"
        ) -> "InfrastructureInput.Builder": ...
        def processingLocation(
            self, processingLocation: "InfrastructureInput.ProcessingLocation"
        ) -> "InfrastructureInput.Builder": ...
        def tiebackLength(self, double: float) -> "InfrastructureInput.Builder": ...
        def waterDepth(self, double: float) -> "InfrastructureInput.Builder": ...

    class ExportType(java.lang.Enum["InfrastructureInput.ExportType"]):
        WET_GAS: typing.ClassVar["InfrastructureInput.ExportType"] = ...
        DRY_GAS: typing.ClassVar["InfrastructureInput.ExportType"] = ...
        STABILIZED_OIL: typing.ClassVar["InfrastructureInput.ExportType"] = ...
        RICH_GAS_CONDENSATE: typing.ClassVar["InfrastructureInput.ExportType"] = ...
        LNG: typing.ClassVar["InfrastructureInput.ExportType"] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: typing.Type[_valueOf_0__T],
            string: typing.Union[java.lang.String, str],
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(
            string: typing.Union[java.lang.String, str]
        ) -> "InfrastructureInput.ExportType": ...
        @staticmethod
        def values() -> typing.MutableSequence["InfrastructureInput.ExportType"]: ...

    class PowerSupply(java.lang.Enum["InfrastructureInput.PowerSupply"]):
        GAS_TURBINE: typing.ClassVar["InfrastructureInput.PowerSupply"] = ...
        POWER_FROM_SHORE: typing.ClassVar["InfrastructureInput.PowerSupply"] = ...
        POWER_FROM_HOST: typing.ClassVar["InfrastructureInput.PowerSupply"] = ...
        HYBRID: typing.ClassVar["InfrastructureInput.PowerSupply"] = ...
        COMBINED_CYCLE: typing.ClassVar["InfrastructureInput.PowerSupply"] = ...
        DIESEL: typing.ClassVar["InfrastructureInput.PowerSupply"] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: typing.Type[_valueOf_0__T],
            string: typing.Union[java.lang.String, str],
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(
            string: typing.Union[java.lang.String, str]
        ) -> "InfrastructureInput.PowerSupply": ...
        @staticmethod
        def values() -> typing.MutableSequence["InfrastructureInput.PowerSupply"]: ...

    class ProcessingLocation(java.lang.Enum["InfrastructureInput.ProcessingLocation"]):
        HOST_PLATFORM: typing.ClassVar["InfrastructureInput.ProcessingLocation"] = ...
        NEW_PLATFORM: typing.ClassVar["InfrastructureInput.ProcessingLocation"] = ...
        PLATFORM: typing.ClassVar["InfrastructureInput.ProcessingLocation"] = ...
        SUBSEA: typing.ClassVar["InfrastructureInput.ProcessingLocation"] = ...
        ONSHORE: typing.ClassVar["InfrastructureInput.ProcessingLocation"] = ...
        FPSO: typing.ClassVar["InfrastructureInput.ProcessingLocation"] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: typing.Type[_valueOf_0__T],
            string: typing.Union[java.lang.String, str],
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(
            string: typing.Union[java.lang.String, str]
        ) -> "InfrastructureInput.ProcessingLocation": ...
        @staticmethod
        def values() -> (
            typing.MutableSequence["InfrastructureInput.ProcessingLocation"]
        ): ...

class ReservoirInput(java.io.Serializable):
    @staticmethod
    def blackOil() -> "ReservoirInput.Builder": ...
    @staticmethod
    def builder() -> "ReservoirInput.Builder": ...
    @staticmethod
    def gasCondensate() -> "ReservoirInput.Builder": ...
    def getApiGravity(self) -> float: ...
    def getCo2Percent(self) -> float: ...
    def getCustomComposition(self) -> java.util.Map[java.lang.String, float]: ...
    def getFluidType(self) -> "ReservoirInput.FluidType": ...
    def getGasGravity(self) -> float: ...
    def getGor(self) -> float: ...
    def getGorUnit(self) -> java.lang.String: ...
    def getH2SPercent(self) -> float: ...
    def getH2sPercent(self) -> float: ...
    def getN2Percent(self) -> float: ...
    def getReservoirPressure(self) -> float: ...
    def getReservoirTemperature(self) -> float: ...
    def getWaterCut(self) -> float: ...
    def getWaterCutPercent(self) -> float: ...
    def getWaterSalinity(self) -> float: ...
    def hasLiquidProduction(self) -> bool: ...
    def hasSignificantWater(self) -> bool: ...
    def isHighCO2(self) -> bool: ...
    def isSour(self) -> bool: ...
    @staticmethod
    def leanGas() -> "ReservoirInput.Builder": ...
    @staticmethod
    def richGas() -> "ReservoirInput.Builder": ...
    def toString(self) -> java.lang.String: ...

    class Builder:
        def addComponent(
            self, string: typing.Union[java.lang.String, str], double: float
        ) -> "ReservoirInput.Builder": ...
        def apiGravity(self, double: float) -> "ReservoirInput.Builder": ...
        def build(self) -> "ReservoirInput": ...
        def co2Percent(self, double: float) -> "ReservoirInput.Builder": ...
        def fluidType(
            self, fluidType: "ReservoirInput.FluidType"
        ) -> "ReservoirInput.Builder": ...
        def gasGravity(self, double: float) -> "ReservoirInput.Builder": ...
        @typing.overload
        def gor(self, double: float) -> "ReservoirInput.Builder": ...
        @typing.overload
        def gor(
            self, double: float, string: typing.Union[java.lang.String, str]
        ) -> "ReservoirInput.Builder": ...
        def h2sPercent(self, double: float) -> "ReservoirInput.Builder": ...
        def n2Percent(self, double: float) -> "ReservoirInput.Builder": ...
        def reservoirPressure(self, double: float) -> "ReservoirInput.Builder": ...
        def reservoirTemperature(self, double: float) -> "ReservoirInput.Builder": ...
        def waterCut(self, double: float) -> "ReservoirInput.Builder": ...
        def waterSalinity(self, double: float) -> "ReservoirInput.Builder": ...

    class FluidType(java.lang.Enum["ReservoirInput.FluidType"]):
        LEAN_GAS: typing.ClassVar["ReservoirInput.FluidType"] = ...
        RICH_GAS: typing.ClassVar["ReservoirInput.FluidType"] = ...
        GAS_CONDENSATE: typing.ClassVar["ReservoirInput.FluidType"] = ...
        VOLATILE_OIL: typing.ClassVar["ReservoirInput.FluidType"] = ...
        BLACK_OIL: typing.ClassVar["ReservoirInput.FluidType"] = ...
        HEAVY_OIL: typing.ClassVar["ReservoirInput.FluidType"] = ...
        CUSTOM: typing.ClassVar["ReservoirInput.FluidType"] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: typing.Type[_valueOf_0__T],
            string: typing.Union[java.lang.String, str],
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(
            string: typing.Union[java.lang.String, str]
        ) -> "ReservoirInput.FluidType": ...
        @staticmethod
        def values() -> typing.MutableSequence["ReservoirInput.FluidType"]: ...

class WellsInput(java.io.Serializable):
    @staticmethod
    def builder() -> "WellsInput.Builder": ...
    def getCompletionType(self) -> "WellsInput.CompletionType": ...
    def getGasLiftRate(self) -> float: ...
    def getGasLiftUnit(self) -> java.lang.String: ...
    def getInjectorCount(self) -> int: ...
    def getProducerCount(self) -> int: ...
    def getProducerType(self) -> "WellsInput.WellType": ...
    def getProductivityIndex(self) -> float: ...
    def getRatePerWell(self) -> float: ...
    def getRatePerWellSm3d(self) -> float: ...
    def getRateUnit(self) -> java.lang.String: ...
    def getShutInPressure(self) -> float: ...
    def getThp(self) -> float: ...
    def getTotalRate(self) -> float: ...
    def getTotalWellCount(self) -> int: ...
    def getTubeheadPressure(self) -> float: ...
    def getWaterInjectionRate(self) -> float: ...
    def getWaterInjectionUnit(self) -> java.lang.String: ...
    def isSubsea(self) -> bool: ...
    def needsArtificialLift(self) -> bool: ...
    def toString(self) -> java.lang.String: ...

    class Builder:
        def build(self) -> "WellsInput": ...
        def completionType(
            self, completionType: "WellsInput.CompletionType"
        ) -> "WellsInput.Builder": ...
        def gasLift(
            self, double: float, string: typing.Union[java.lang.String, str]
        ) -> "WellsInput.Builder": ...
        def injectorCount(self, int: int) -> "WellsInput.Builder": ...
        def producerCount(self, int: int) -> "WellsInput.Builder": ...
        def producerType(
            self, wellType: "WellsInput.WellType"
        ) -> "WellsInput.Builder": ...
        def productivityIndex(self, double: float) -> "WellsInput.Builder": ...
        def ratePerWell(
            self, double: float, string: typing.Union[java.lang.String, str]
        ) -> "WellsInput.Builder": ...
        def shutInPressure(self, double: float) -> "WellsInput.Builder": ...
        def thp(self, double: float) -> "WellsInput.Builder": ...
        def tubeheadPressure(self, double: float) -> "WellsInput.Builder": ...
        def waterInjection(
            self, double: float, string: typing.Union[java.lang.String, str]
        ) -> "WellsInput.Builder": ...

    class CompletionType(java.lang.Enum["WellsInput.CompletionType"]):
        SUBSEA: typing.ClassVar["WellsInput.CompletionType"] = ...
        PLATFORM: typing.ClassVar["WellsInput.CompletionType"] = ...
        ONSHORE: typing.ClassVar["WellsInput.CompletionType"] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: typing.Type[_valueOf_0__T],
            string: typing.Union[java.lang.String, str],
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(
            string: typing.Union[java.lang.String, str]
        ) -> "WellsInput.CompletionType": ...
        @staticmethod
        def values() -> typing.MutableSequence["WellsInput.CompletionType"]: ...

    class WellType(java.lang.Enum["WellsInput.WellType"]):
        NATURAL_FLOW: typing.ClassVar["WellsInput.WellType"] = ...
        GAS_LIFT: typing.ClassVar["WellsInput.WellType"] = ...
        ESP: typing.ClassVar["WellsInput.WellType"] = ...
        WATER_INJECTOR: typing.ClassVar["WellsInput.WellType"] = ...
        GAS_INJECTOR: typing.ClassVar["WellsInput.WellType"] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: typing.Type[_valueOf_0__T],
            string: typing.Union[java.lang.String, str],
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(
            string: typing.Union[java.lang.String, str]
        ) -> "WellsInput.WellType": ...
        @staticmethod
        def values() -> typing.MutableSequence["WellsInput.WellType"]: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.process.fielddevelopment.concept")``.

    FieldConcept: typing.Type[FieldConcept]
    InfrastructureInput: typing.Type[InfrastructureInput]
    ReservoirInput: typing.Type[ReservoirInput]
    WellsInput: typing.Type[WellsInput]
