import sys

if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.util
import jneqsim.process.fielddevelopment.concept
import typing

class BlockConfig(java.io.Serializable):
    @staticmethod
    def co2Amine(double: float) -> "BlockConfig": ...
    @staticmethod
    def co2Membrane(double: float) -> "BlockConfig": ...
    @typing.overload
    @staticmethod
    def compression(int: int) -> "BlockConfig": ...
    @typing.overload
    @staticmethod
    def compression(int: int, double: float) -> "BlockConfig": ...
    def getDoubleParameter(
        self, string: typing.Union[java.lang.String, str], double: float
    ) -> float: ...
    def getIntParameter(
        self, string: typing.Union[java.lang.String, str], int: int
    ) -> int: ...
    def getName(self) -> java.lang.String: ...
    _getParameter__T = typing.TypeVar("_getParameter__T")  # <T>
    def getParameter(
        self, string: typing.Union[java.lang.String, str], t: _getParameter__T
    ) -> _getParameter__T: ...
    def getParameters(self) -> java.util.Map[java.lang.String, typing.Any]: ...
    def getType(self) -> "BlockType": ...
    @staticmethod
    def inletSeparation(double: float, double2: float) -> "BlockConfig": ...
    @typing.overload
    @staticmethod
    def of(blockType: "BlockType") -> "BlockConfig": ...
    @typing.overload
    @staticmethod
    def of(
        blockType: "BlockType", string: typing.Union[java.lang.String, str]
    ) -> "BlockConfig": ...
    @typing.overload
    @staticmethod
    def of(
        blockType: "BlockType",
        map: typing.Union[
            java.util.Map[typing.Union[java.lang.String, str], typing.Any],
            typing.Mapping[typing.Union[java.lang.String, str], typing.Any],
        ],
    ) -> "BlockConfig": ...
    @staticmethod
    def oilStabilization(int: int, double: float) -> "BlockConfig": ...
    @staticmethod
    def tegDehydration(double: float) -> "BlockConfig": ...
    def toString(self) -> java.lang.String: ...

class BlockType(java.lang.Enum["BlockType"]):
    INLET_SEPARATION: typing.ClassVar["BlockType"] = ...
    TWO_PHASE_SEPARATOR: typing.ClassVar["BlockType"] = ...
    THREE_PHASE_SEPARATOR: typing.ClassVar["BlockType"] = ...
    COMPRESSION: typing.ClassVar["BlockType"] = ...
    TEG_DEHYDRATION: typing.ClassVar["BlockType"] = ...
    MEG_REGENERATION: typing.ClassVar["BlockType"] = ...
    CO2_REMOVAL_MEMBRANE: typing.ClassVar["BlockType"] = ...
    CO2_REMOVAL_AMINE: typing.ClassVar["BlockType"] = ...
    H2S_REMOVAL: typing.ClassVar["BlockType"] = ...
    NGL_RECOVERY: typing.ClassVar["BlockType"] = ...
    DEW_POINT_CONTROL: typing.ClassVar["BlockType"] = ...
    EXPORT_CONDITIONING: typing.ClassVar["BlockType"] = ...
    OIL_STABILIZATION: typing.ClassVar["BlockType"] = ...
    WATER_TREATMENT: typing.ClassVar["BlockType"] = ...
    SUBSEA_BOOSTING: typing.ClassVar["BlockType"] = ...
    GAS_COOLING: typing.ClassVar["BlockType"] = ...
    HEAT_EXCHANGE: typing.ClassVar["BlockType"] = ...
    FLARE_SYSTEM: typing.ClassVar["BlockType"] = ...
    POWER_GENERATION: typing.ClassVar["BlockType"] = ...
    def getDescription(self) -> java.lang.String: ...
    def getDisplayName(self) -> java.lang.String: ...
    def isEmissionSource(self) -> bool: ...
    def isHighCapex(self) -> bool: ...
    def isPowerConsumer(self) -> bool: ...
    _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(
        class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]
    ) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: typing.Union[java.lang.String, str]) -> "BlockType": ...
    @staticmethod
    def values() -> typing.MutableSequence["BlockType"]: ...

class FacilityBuilder(java.io.Serializable):
    @typing.overload
    def addBlock(self, blockConfig: BlockConfig) -> "FacilityBuilder": ...
    @typing.overload
    def addBlock(self, blockType: BlockType) -> "FacilityBuilder": ...
    def addCo2Amine(self, double: float) -> "FacilityBuilder": ...
    def addCo2Membrane(self, double: float) -> "FacilityBuilder": ...
    @typing.overload
    def addCompression(self, int: int) -> "FacilityBuilder": ...
    @typing.overload
    def addCompression(self, int: int, double: float) -> "FacilityBuilder": ...
    def addTegDehydration(self, double: float) -> "FacilityBuilder": ...
    @staticmethod
    def autoGenerate(
        fieldConcept: jneqsim.process.fielddevelopment.concept.FieldConcept,
    ) -> "FacilityBuilder": ...
    def build(self) -> "FacilityConfig": ...
    def designMargin(self, double: float) -> "FacilityBuilder": ...
    @staticmethod
    def forConcept(
        fieldConcept: jneqsim.process.fielddevelopment.concept.FieldConcept,
    ) -> "FacilityBuilder": ...
    def includeFlare(self, boolean: bool) -> "FacilityBuilder": ...
    def includePowerGeneration(self, boolean: bool) -> "FacilityBuilder": ...
    def name(
        self, string: typing.Union[java.lang.String, str]
    ) -> "FacilityBuilder": ...
    def withRedundancy(
        self, string: typing.Union[java.lang.String, str], int: int
    ) -> "FacilityBuilder": ...

class FacilityConfig(java.io.Serializable):
    def getBlockCount(self) -> int: ...
    def getBlocks(self) -> java.util.List[BlockConfig]: ...
    def getBlocksOfType(self, blockType: BlockType) -> java.util.List[BlockConfig]: ...
    def getConcept(self) -> jneqsim.process.fielddevelopment.concept.FieldConcept: ...
    def getDesignMargin(self) -> float: ...
    def getName(self) -> java.lang.String: ...
    def getRedundancyRequirements(self) -> java.util.List[java.lang.String]: ...
    def getSummary(self) -> java.lang.String: ...
    def getTotalCompressionStages(self) -> int: ...
    def hasBlock(self, blockType: BlockType) -> bool: ...
    def hasCo2Removal(self) -> bool: ...
    def hasCompression(self) -> bool: ...
    def hasDehydration(self) -> bool: ...
    def isComplex(self) -> bool: ...
    def toString(self) -> java.lang.String: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.process.fielddevelopment.facility")``.

    BlockConfig: typing.Type[BlockConfig]
    BlockType: typing.Type[BlockType]
    FacilityBuilder: typing.Type[FacilityBuilder]
    FacilityConfig: typing.Type[FacilityConfig]
