import sys

if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import datetime
import java.io
import java.lang
import java.time
import java.util
import java.util.function
import jpype
import jneqsim.process.processmodel
import jneqsim.process.util.uncertainty
import jneqsim.statistics.parameterfitting.nonlinearparameterfitting
import typing

class BatchParameterEstimator(java.io.Serializable):
    def __init__(self, processSystem: jneqsim.process.processmodel.ProcessSystem): ...
    @typing.overload
    def addDataPoint(
        self,
        map: typing.Union[
            java.util.Map[typing.Union[java.lang.String, str], float],
            typing.Mapping[typing.Union[java.lang.String, str], float],
        ],
    ) -> "BatchParameterEstimator": ...
    @typing.overload
    def addDataPoint(
        self,
        map: typing.Union[
            java.util.Map[typing.Union[java.lang.String, str], float],
            typing.Mapping[typing.Union[java.lang.String, str], float],
        ],
        map2: typing.Union[
            java.util.Map[typing.Union[java.lang.String, str], float],
            typing.Mapping[typing.Union[java.lang.String, str], float],
        ],
    ) -> "BatchParameterEstimator": ...
    def addMeasuredVariable(
        self,
        string: typing.Union[java.lang.String, str],
        string2: typing.Union[java.lang.String, str],
        double: float,
    ) -> "BatchParameterEstimator": ...
    def addTunableParameter(
        self,
        string: typing.Union[java.lang.String, str],
        string2: typing.Union[java.lang.String, str],
        double: float,
        double2: float,
        double3: float,
    ) -> "BatchParameterEstimator": ...
    def clearDataPoints(self) -> "BatchParameterEstimator": ...
    def displayCurveFit(self) -> None: ...
    def displayResult(self) -> None: ...
    def getDataPointCount(self) -> int: ...
    def getLastResult(self) -> "BatchResult": ...
    def getMeasurementNames(self) -> typing.MutableSequence[java.lang.String]: ...
    def getOptimizer(
        self,
    ) -> (
        jneqsim.statistics.parameterfitting.nonlinearparameterfitting.LevenbergMarquardt
    ): ...
    def getParameterNames(self) -> typing.MutableSequence[java.lang.String]: ...
    def getProcessSystem(self) -> jneqsim.process.processmodel.ProcessSystem: ...
    def reset(self) -> "BatchParameterEstimator": ...
    def runMonteCarloSimulation(self, int: int) -> None: ...
    def setMaxIterations(self, int: int) -> "BatchParameterEstimator": ...
    def setUseAnalyticalJacobian(self, boolean: bool) -> "BatchParameterEstimator": ...
    def solve(self) -> "BatchResult": ...
    def toCalibrationResult(self) -> "CalibrationResult": ...

    class DataPoint(java.io.Serializable):
        def __init__(
            self,
            map: typing.Union[
                java.util.Map[typing.Union[java.lang.String, str], float],
                typing.Mapping[typing.Union[java.lang.String, str], float],
            ],
            map2: typing.Union[
                java.util.Map[typing.Union[java.lang.String, str], float],
                typing.Mapping[typing.Union[java.lang.String, str], float],
            ],
        ): ...
        def getConditions(self) -> java.util.Map[java.lang.String, float]: ...
        def getMeasurements(self) -> java.util.Map[java.lang.String, float]: ...

    class MeasuredVariable(java.io.Serializable):
        def __init__(
            self,
            string: typing.Union[java.lang.String, str],
            string2: typing.Union[java.lang.String, str],
            double: float,
        ): ...
        def getPath(self) -> java.lang.String: ...
        def getStandardDeviation(self) -> float: ...
        def getUnit(self) -> java.lang.String: ...

    class TunableParameter(java.io.Serializable):
        def __init__(
            self,
            string: typing.Union[java.lang.String, str],
            string2: typing.Union[java.lang.String, str],
            double: float,
            double2: float,
            double3: float,
        ): ...
        def getInitialGuess(self) -> float: ...
        def getLowerBound(self) -> float: ...
        def getPath(self) -> java.lang.String: ...
        def getUnit(self) -> java.lang.String: ...
        def getUpperBound(self) -> float: ...

class BatchResult(java.io.Serializable):
    @typing.overload
    def __init__(
        self,
        stringArray: typing.Union[typing.List[java.lang.String], jpype.JArray],
        doubleArray: typing.Union[typing.List[float], jpype.JArray],
        doubleArray2: typing.Union[typing.List[float], jpype.JArray],
        double3: float,
        int: int,
        int2: int,
        boolean: bool,
    ): ...
    @typing.overload
    def __init__(
        self,
        stringArray: typing.Union[typing.List[java.lang.String], jpype.JArray],
        doubleArray: typing.Union[typing.List[float], jpype.JArray],
        doubleArray2: typing.Union[typing.List[float], jpype.JArray],
        double3: float,
        int: int,
        int2: int,
        boolean: bool,
        doubleArray3: typing.Union[
            typing.List[typing.MutableSequence[float]], jpype.JArray
        ],
        doubleArray4: typing.Union[
            typing.List[typing.MutableSequence[float]], jpype.JArray
        ],
        double6: float,
        double7: float,
        double8: float,
    ): ...
    def getBias(self) -> float: ...
    def getChiSquare(self) -> float: ...
    def getConfidenceIntervalLower(self) -> typing.MutableSequence[float]: ...
    def getConfidenceIntervalUpper(self) -> typing.MutableSequence[float]: ...
    def getCorrelationMatrix(
        self,
    ) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def getCovarianceMatrix(
        self,
    ) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def getDataPointCount(self) -> int: ...
    def getDegreesOfFreedom(self) -> int: ...
    @typing.overload
    def getEstimate(self, int: int) -> float: ...
    @typing.overload
    def getEstimate(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getEstimates(self) -> typing.MutableSequence[float]: ...
    def getIterations(self) -> int: ...
    def getMeanAbsoluteDeviation(self) -> float: ...
    def getParameterNames(self) -> typing.MutableSequence[java.lang.String]: ...
    def getRMSE(self) -> float: ...
    def getRSquared(self) -> float: ...
    def getReducedChiSquare(self) -> float: ...
    def getUncertainties(self) -> typing.MutableSequence[float]: ...
    def getUncertainty(self, int: int) -> float: ...
    def isConverged(self) -> bool: ...
    def printSummary(self) -> None: ...
    def toCalibrationResult(self) -> "CalibrationResult": ...
    def toMap(self) -> java.util.Map[java.lang.String, float]: ...
    def toString(self) -> java.lang.String: ...

class CalibrationFrameworkExample:
    def __init__(self): ...
    def buildNetwork(self) -> None: ...
    def createEstimator(self) -> "EnKFParameterEstimator": ...
    @staticmethod
    def main(
        stringArray: typing.Union[typing.List[java.lang.String], jpype.JArray]
    ) -> None: ...
    def runLiveEstimation(self) -> None: ...
    def runValidationTests(self) -> None: ...

class CalibrationQuality(java.io.Serializable):
    def __init__(
        self,
        instant: typing.Union[java.time.Instant, datetime.datetime],
        double: float,
        double2: float,
        double3: float,
        double4: float,
        int: int,
        double5: float,
    ): ...
    def getCoverage(self) -> float: ...
    def getMae(self) -> float: ...
    def getMse(self) -> float: ...
    def getOverallScore(self) -> float: ...
    def getR2(self) -> float: ...
    def getRating(self) -> java.lang.String: ...
    def getRmse(self) -> float: ...
    def getSampleCount(self) -> int: ...
    def getTimestamp(self) -> java.time.Instant: ...
    def isAcceptable(self, double: float, double2: float) -> bool: ...
    def toString(self) -> java.lang.String: ...

class CalibrationResult(java.io.Serializable):
    @staticmethod
    def failure(string: typing.Union[java.lang.String, str]) -> "CalibrationResult": ...
    def getCalibratedParameters(self) -> java.util.Map[java.lang.String, float]: ...
    def getErrorMessage(self) -> java.lang.String: ...
    def getIterations(self) -> int: ...
    def getMessage(self) -> java.lang.String: ...
    def getParameters(self) -> java.util.Map[java.lang.String, float]: ...
    def getRmse(self) -> float: ...
    def getSamplesUsed(self) -> int: ...
    def isSuccess(self) -> bool: ...
    def isSuccessful(self) -> bool: ...
    @staticmethod
    def success(
        map: typing.Union[
            java.util.Map[typing.Union[java.lang.String, str], float],
            typing.Mapping[typing.Union[java.lang.String, str], float],
        ],
        double: float,
        int: int,
        int2: int,
    ) -> "CalibrationResult": ...
    def toString(self) -> java.lang.String: ...

class EnKFParameterEstimator(java.io.Serializable):
    def __init__(self, processSystem: jneqsim.process.processmodel.ProcessSystem): ...
    def addMeasuredVariable(
        self,
        string: typing.Union[java.lang.String, str],
        string2: typing.Union[java.lang.String, str],
        double: float,
    ) -> "EnKFParameterEstimator": ...
    @typing.overload
    def addTunableParameter(
        self,
        string: typing.Union[java.lang.String, str],
        string2: typing.Union[java.lang.String, str],
        double: float,
        double2: float,
        double3: float,
    ) -> "EnKFParameterEstimator": ...
    @typing.overload
    def addTunableParameter(
        self,
        string: typing.Union[java.lang.String, str],
        string2: typing.Union[java.lang.String, str],
        double: float,
        double2: float,
        double3: float,
        double4: float,
    ) -> "EnKFParameterEstimator": ...
    def getEstimates(self) -> typing.MutableSequence[float]: ...
    def getHistory(self) -> java.util.List["EnKFParameterEstimator.EnKFResult"]: ...
    def getMeasurementNames(self) -> typing.MutableSequence[java.lang.String]: ...
    def getParameterNames(self) -> typing.MutableSequence[java.lang.String]: ...
    def getUncertainties(self) -> typing.MutableSequence[float]: ...
    def getUpdateCount(self) -> int: ...
    def initialize(self, int: int, long: int) -> None: ...
    def reset(self) -> None: ...
    def setMaxChangePerUpdate(self, double: float) -> "EnKFParameterEstimator": ...
    def setProcessNoise(self, double: float) -> "EnKFParameterEstimator": ...
    def toCalibrationResult(self) -> CalibrationResult: ...
    def update(
        self,
        map: typing.Union[
            java.util.Map[typing.Union[java.lang.String, str], float],
            typing.Mapping[typing.Union[java.lang.String, str], float],
        ],
    ) -> "EnKFParameterEstimator.EnKFResult": ...

    class EnKFResult(java.io.Serializable):
        def __init__(
            self,
            int: int,
            doubleArray: typing.Union[typing.List[float], jpype.JArray],
            doubleArray2: typing.Union[typing.List[float], jpype.JArray],
            doubleArray3: typing.Union[typing.List[float], jpype.JArray],
            doubleArray4: typing.Union[typing.List[float], jpype.JArray],
            boolean: bool,
        ): ...
        def getConfidenceIntervalLower(self) -> typing.MutableSequence[float]: ...
        def getConfidenceIntervalUpper(self) -> typing.MutableSequence[float]: ...
        def getEstimates(self) -> typing.MutableSequence[float]: ...
        def getMeasurements(self) -> typing.MutableSequence[float]: ...
        def getPredictions(self) -> typing.MutableSequence[float]: ...
        def getRMSE(self) -> float: ...
        def getStep(self) -> int: ...
        def getUncertainties(self) -> typing.MutableSequence[float]: ...
        def isAnomalyDetected(self) -> bool: ...
        def toCalibrationResult(
            self, stringArray: typing.Union[typing.List[java.lang.String], jpype.JArray]
        ) -> CalibrationResult: ...

    class MeasuredVariableSpec(java.io.Serializable):
        path: java.lang.String = ...
        unit: java.lang.String = ...
        noiseStd: float = ...
        def __init__(
            self,
            string: typing.Union[java.lang.String, str],
            string2: typing.Union[java.lang.String, str],
            double: float,
        ): ...

    class TunableParameterSpec(java.io.Serializable):
        path: java.lang.String = ...
        unit: java.lang.String = ...
        minValue: float = ...
        maxValue: float = ...
        initialValue: float = ...
        initialUncertainty: float = ...
        def __init__(
            self,
            string: typing.Union[java.lang.String, str],
            string2: typing.Union[java.lang.String, str],
            double: float,
            double2: float,
            double3: float,
            double4: float,
        ): ...

class EstimationTestHarness(java.io.Serializable):
    def __init__(self, processSystem: jneqsim.process.processmodel.ProcessSystem): ...
    def addMeasurement(
        self,
        string: typing.Union[java.lang.String, str],
        string2: typing.Union[java.lang.String, str],
        double: float,
    ) -> "EstimationTestHarness": ...
    @typing.overload
    def addParameter(
        self, string: typing.Union[java.lang.String, str], double: float
    ) -> "EstimationTestHarness": ...
    @typing.overload
    def addParameter(
        self,
        string: typing.Union[java.lang.String, str],
        double: float,
        double2: float,
        double3: float,
    ) -> "EstimationTestHarness": ...
    def generateMeasurement(
        self, double: float
    ) -> java.util.Map[java.lang.String, float]: ...
    @typing.overload
    def runConvergenceTest(
        self, enKFParameterEstimator: EnKFParameterEstimator, int: int
    ) -> "EstimationTestHarness.TestReport": ...
    @typing.overload
    def runConvergenceTest(
        self,
        enKFParameterEstimator: EnKFParameterEstimator,
        int: int,
        double: float,
        consumer: typing.Union[
            java.util.function.Consumer[int], typing.Callable[[int], None]
        ],
    ) -> "EstimationTestHarness.TestReport": ...
    def runDriftTrackingTest(
        self,
        enKFParameterEstimator: EnKFParameterEstimator,
        int: int,
        int2: int,
        double: float,
    ) -> "EstimationTestHarness.TestReport": ...
    def runMonteCarloValidation(
        self,
        supplier: typing.Union[
            java.util.function.Supplier[EnKFParameterEstimator],
            typing.Callable[[], EnKFParameterEstimator],
        ],
        int: int,
        int2: int,
    ) -> "EstimationTestHarness.MonteCarloReport": ...
    def runNoiseRobustnessTest(
        self,
        enKFParameterEstimator: EnKFParameterEstimator,
        int: int,
        doubleArray: typing.Union[typing.List[float], jpype.JArray],
    ) -> java.util.Map[float, "EstimationTestHarness.TestReport"]: ...
    def setSeed(self, long: int) -> "EstimationTestHarness": ...

    class MeasurementSpec(java.io.Serializable):
        path: java.lang.String = ...
        unit: java.lang.String = ...
        noiseStd: float = ...
        def __init__(
            self,
            string: typing.Union[java.lang.String, str],
            string2: typing.Union[java.lang.String, str],
            double: float,
        ): ...

    class MonteCarloReport(java.io.Serializable):
        def __init__(
            self,
            int: int,
            int2: int,
            list: java.util.List[float],
            list2: java.util.List[float],
            int3: int,
        ): ...
        def getMeanCoverage(self) -> float: ...
        def getMeanRMSE(self) -> float: ...
        def getPercentile95RMSE(self) -> float: ...
        def getStdRMSE(self) -> float: ...
        def getSuccessRate(self) -> float: ...
        def printSummary(self) -> None: ...

    class ParameterWithTruth(java.io.Serializable):
        path: java.lang.String = ...
        trueValue: float = ...
        minBound: float = ...
        maxBound: float = ...
        def __init__(
            self,
            string: typing.Union[java.lang.String, str],
            double: float,
            double2: float,
            double3: float,
        ): ...

    class TestReport(java.io.Serializable):
        def __init__(
            self,
            string: typing.Union[java.lang.String, str],
            int: int,
            doubleArray: typing.Union[typing.List[float], jpype.JArray],
            doubleArray2: typing.Union[typing.List[float], jpype.JArray],
            doubleArray3: typing.Union[typing.List[float], jpype.JArray],
            list: java.util.List[typing.Union[typing.List[float], jpype.JArray]],
            list2: java.util.List[typing.Union[typing.List[float], jpype.JArray]],
        ): ...
        def getCoverageRate(self) -> float: ...
        def getFinalEstimates(self) -> typing.MutableSequence[float]: ...
        def getMaxError(self) -> float: ...
        def getMeanAbsoluteError(self) -> float: ...
        def getRMSE(self) -> float: ...
        def getStepsToConverge(self) -> int: ...
        def getTestName(self) -> java.lang.String: ...
        def getTrueValues(self) -> typing.MutableSequence[float]: ...
        def passes(self, double: float, double2: float, int: int) -> bool: ...
        def printSummary(self) -> None: ...

class OnlineCalibrator(java.io.Serializable):
    def __init__(self, processSystem: jneqsim.process.processmodel.ProcessSystem): ...
    def clearHistory(self) -> None: ...
    def exportHistory(self) -> java.util.List["OnlineCalibrator.DataPoint"]: ...
    def fullRecalibration(self) -> CalibrationResult: ...
    def getHistorySize(self) -> int: ...
    def getLastCalibrationTime(self) -> java.time.Instant: ...
    def getQualityMetrics(self) -> CalibrationQuality: ...
    def incrementalUpdate(
        self,
        map: typing.Union[
            java.util.Map[typing.Union[java.lang.String, str], float],
            typing.Mapping[typing.Union[java.lang.String, str], float],
        ],
        map2: typing.Union[
            java.util.Map[typing.Union[java.lang.String, str], float],
            typing.Mapping[typing.Union[java.lang.String, str], float],
        ],
    ) -> CalibrationResult: ...
    @typing.overload
    def recordDataPoint(
        self,
        map: typing.Union[
            java.util.Map[typing.Union[java.lang.String, str], float],
            typing.Mapping[typing.Union[java.lang.String, str], float],
        ],
        map2: typing.Union[
            java.util.Map[typing.Union[java.lang.String, str], float],
            typing.Mapping[typing.Union[java.lang.String, str], float],
        ],
    ) -> bool: ...
    @typing.overload
    def recordDataPoint(
        self,
        map: typing.Union[
            java.util.Map[typing.Union[java.lang.String, str], float],
            typing.Mapping[typing.Union[java.lang.String, str], float],
        ],
        map2: typing.Union[
            java.util.Map[typing.Union[java.lang.String, str], float],
            typing.Mapping[typing.Union[java.lang.String, str], float],
        ],
        map3: typing.Union[
            java.util.Map[typing.Union[java.lang.String, str], float],
            typing.Mapping[typing.Union[java.lang.String, str], float],
        ],
    ) -> bool: ...
    def setDeviationThreshold(self, double: float) -> None: ...
    def setMaxHistorySize(self, int: int) -> None: ...
    def setTunableParameters(
        self, list: java.util.List[typing.Union[java.lang.String, str]]
    ) -> None: ...

    class DataPoint(java.io.Serializable):
        def __init__(
            self,
            map: typing.Union[
                java.util.Map[typing.Union[java.lang.String, str], float],
                typing.Mapping[typing.Union[java.lang.String, str], float],
            ],
            map2: typing.Union[
                java.util.Map[typing.Union[java.lang.String, str], float],
                typing.Mapping[typing.Union[java.lang.String, str], float],
            ],
            map3: typing.Union[
                java.util.Map[typing.Union[java.lang.String, str], float],
                typing.Mapping[typing.Union[java.lang.String, str], float],
            ],
        ): ...
        def getConditions(self) -> java.util.Map[java.lang.String, float]: ...
        def getError(self, string: typing.Union[java.lang.String, str]) -> float: ...
        def getMeasurements(self) -> java.util.Map[java.lang.String, float]: ...
        def getPredictions(self) -> java.util.Map[java.lang.String, float]: ...
        def getRelativeError(
            self, string: typing.Union[java.lang.String, str]
        ) -> float: ...
        def getTimestamp(self) -> java.time.Instant: ...

class ProcessSimulationFunction(
    jneqsim.statistics.parameterfitting.nonlinearparameterfitting.LevenbergMarquardtFunction
):
    def __init__(self, processSystem: jneqsim.process.processmodel.ProcessSystem): ...
    def addDataPointConditions(
        self,
        map: typing.Union[
            java.util.Map[typing.Union[java.lang.String, str], float],
            typing.Mapping[typing.Union[java.lang.String, str], float],
        ],
    ) -> None: ...
    def addMeasurement(
        self, string: typing.Union[java.lang.String, str]
    ) -> "ProcessSimulationFunction": ...
    def addParameter(
        self, string: typing.Union[java.lang.String, str], double: float, double2: float
    ) -> "ProcessSimulationFunction": ...
    def calcValue(
        self, doubleArray: typing.Union[typing.List[float], jpype.JArray]
    ) -> float: ...
    def computeAnalyticalJacobian(
        self,
    ) -> jneqsim.process.util.uncertainty.SensitivityMatrix: ...
    def getMeasurementCount(self) -> int: ...
    def getMeasurementPaths(self) -> java.util.List[java.lang.String]: ...
    def getParameterCount(self) -> int: ...
    def getParameterPaths(self) -> java.util.List[java.lang.String]: ...
    def getProcessSystem(self) -> jneqsim.process.processmodel.ProcessSystem: ...
    def getSensitivity(self, int: int, int2: int) -> float: ...
    def setCurrentIndices(self, int: int, int2: int) -> None: ...
    @typing.overload
    def setFittingParams(self, int: int, double: float) -> None: ...
    @typing.overload
    def setFittingParams(
        self, doubleArray: typing.Union[typing.List[float], jpype.JArray]
    ) -> None: ...
    def setUseAnalyticalJacobian(self, boolean: bool) -> None: ...

class WellRoutingEstimationExample:
    def __init__(self): ...
    def buildNetwork(self) -> None: ...
    def createEstimator(self) -> EnKFParameterEstimator: ...
    def createTestHarness(self) -> EstimationTestHarness: ...
    def getMeasurementsWithNoise(self) -> java.util.Map[java.lang.String, float]: ...
    def getRoutingSchedule(
        self,
    ) -> typing.MutableSequence[typing.MutableSequence[int]]: ...
    @staticmethod
    def main(
        stringArray: typing.Union[typing.List[java.lang.String], jpype.JArray]
    ) -> None: ...
    def runLiveEstimation(
        self, enKFParameterEstimator: EnKFParameterEstimator
    ) -> None: ...
    def runValidation(
        self,
        enKFParameterEstimator: EnKFParameterEstimator,
        estimationTestHarness: EstimationTestHarness,
    ) -> bool: ...
    def setRouting(
        self, intArray: typing.Union[typing.List[int], jpype.JArray]
    ) -> None: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.process.calibration")``.

    BatchParameterEstimator: typing.Type[BatchParameterEstimator]
    BatchResult: typing.Type[BatchResult]
    CalibrationFrameworkExample: typing.Type[CalibrationFrameworkExample]
    CalibrationQuality: typing.Type[CalibrationQuality]
    CalibrationResult: typing.Type[CalibrationResult]
    EnKFParameterEstimator: typing.Type[EnKFParameterEstimator]
    EstimationTestHarness: typing.Type[EstimationTestHarness]
    OnlineCalibrator: typing.Type[OnlineCalibrator]
    ProcessSimulationFunction: typing.Type[ProcessSimulationFunction]
    WellRoutingEstimationExample: typing.Type[WellRoutingEstimationExample]
