
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.lang
import java.util
import jneqsim.fluidmechanics.flowsolver
import jneqsim.process.equipment
import jneqsim.process.equipment.mixer
import jneqsim.process.equipment.pipeline
import jneqsim.process.equipment.reservoir
import jneqsim.process.equipment.stream
import jneqsim.process.equipment.valve
import jneqsim.process.util.report
import typing



class PipeFlowNetwork(jneqsim.process.equipment.ProcessEquipmentBaseClass):
    def __init__(self, string: typing.Union[java.lang.String, str]): ...
    def addInletPipeline(self, string: typing.Union[java.lang.String, str], streamInterface: jneqsim.process.equipment.stream.StreamInterface, string2: typing.Union[java.lang.String, str], double: float, double2: float, int: int) -> 'PipeFlowNetwork.PipelineSegment': ...
    def connectManifolds(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], string3: typing.Union[java.lang.String, str], double: float, double2: float, int: int) -> 'PipeFlowNetwork.PipelineSegment': ...
    def createManifold(self, string: typing.Union[java.lang.String, str]) -> java.lang.String: ...
    def getCompositionProfile(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> typing.MutableSequence[float]: ...
    def getManifolds(self) -> java.util.Map[java.lang.String, 'PipeFlowNetwork.ManifoldNode']: ...
    def getOutletStream(self) -> jneqsim.process.equipment.stream.StreamInterface: ...
    def getPipelines(self) -> java.util.List['PipeFlowNetwork.PipelineSegment']: ...
    def getPressureProfile(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> typing.MutableSequence[float]: ...
    def getSimulationTime(self) -> float: ...
    def getTemperatureProfile(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> typing.MutableSequence[float]: ...
    def getTerminalManifold(self) -> 'PipeFlowNetwork.ManifoldNode': ...
    def getTotalPressureDrop(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getVelocityProfile(self, string: typing.Union[java.lang.String, str]) -> typing.MutableSequence[float]: ...
    def resetSimulationTime(self) -> None: ...
    @typing.overload
    def run(self) -> None: ...
    @typing.overload
    def run(self, uUID: java.util.UUID) -> None: ...
    @typing.overload
    def runTransient(self, double: float) -> None: ...
    @typing.overload
    def runTransient(self, double: float, uUID: java.util.UUID) -> None: ...
    def setAdvectionScheme(self, advectionScheme: jneqsim.fluidmechanics.flowsolver.AdvectionScheme) -> None: ...
    def setCompositionalTracking(self, boolean: bool) -> None: ...
    def setDefaultHeatTransferCoefficients(self, double: float, double2: float) -> None: ...
    def setDefaultOuterTemperature(self, double: float) -> None: ...
    def setDefaultWallRoughness(self, double: float) -> None: ...
    @typing.overload
    def toJson(self, reportConfig: jneqsim.process.util.report.ReportConfig) -> java.lang.String: ...
    @typing.overload
    def toJson(self) -> java.lang.String: ...
    class ManifoldNode:
        def getInboundPipelines(self) -> java.util.List['PipeFlowNetwork.PipelineSegment']: ...
        def getMixer(self) -> jneqsim.process.equipment.mixer.Mixer: ...
        def getName(self) -> java.lang.String: ...
        def getOutboundPipeline(self) -> 'PipeFlowNetwork.PipelineSegment': ...
    class PipelineSegment:
        def getFromManifold(self) -> java.lang.String: ...
        def getName(self) -> java.lang.String: ...
        def getPipeline(self) -> jneqsim.process.equipment.pipeline.OnePhasePipeLine: ...
        def getToManifold(self) -> java.lang.String: ...
        def isInletPipeline(self) -> bool: ...

class WellFlowlineNetwork(jneqsim.process.equipment.ProcessEquipmentBaseClass):
    def __init__(self, string: typing.Union[java.lang.String, str]): ...
    @typing.overload
    def addBranch(self, string: typing.Union[java.lang.String, str], wellFlow: jneqsim.process.equipment.reservoir.WellFlow, pipeBeggsAndBrills: jneqsim.process.equipment.pipeline.PipeBeggsAndBrills) -> 'WellFlowlineNetwork.Branch': ...
    @typing.overload
    def addBranch(self, string: typing.Union[java.lang.String, str], wellFlow: jneqsim.process.equipment.reservoir.WellFlow, pipeBeggsAndBrills: jneqsim.process.equipment.pipeline.PipeBeggsAndBrills, manifoldNode: 'WellFlowlineNetwork.ManifoldNode') -> 'WellFlowlineNetwork.Branch': ...
    @typing.overload
    def addBranch(self, string: typing.Union[java.lang.String, str], wellFlow: jneqsim.process.equipment.reservoir.WellFlow, pipeBeggsAndBrills: jneqsim.process.equipment.pipeline.PipeBeggsAndBrills, throttlingValve: jneqsim.process.equipment.valve.ThrottlingValve, manifoldNode: 'WellFlowlineNetwork.ManifoldNode') -> 'WellFlowlineNetwork.Branch': ...
    @typing.overload
    def addBranch(self, string: typing.Union[java.lang.String, str], streamInterface: jneqsim.process.equipment.stream.StreamInterface) -> 'WellFlowlineNetwork.Branch': ...
    @typing.overload
    def addBranch(self, string: typing.Union[java.lang.String, str], streamInterface: jneqsim.process.equipment.stream.StreamInterface, manifoldNode: 'WellFlowlineNetwork.ManifoldNode') -> 'WellFlowlineNetwork.Branch': ...
    def addManifold(self, string: typing.Union[java.lang.String, str], pipeBeggsAndBrills: jneqsim.process.equipment.pipeline.PipeBeggsAndBrills) -> 'WellFlowlineNetwork.ManifoldNode': ...
    def connectManifolds(self, manifoldNode: 'WellFlowlineNetwork.ManifoldNode', manifoldNode2: 'WellFlowlineNetwork.ManifoldNode', pipeBeggsAndBrills: jneqsim.process.equipment.pipeline.PipeBeggsAndBrills) -> None: ...
    def createManifold(self, string: typing.Union[java.lang.String, str]) -> 'WellFlowlineNetwork.ManifoldNode': ...
    def getArrivalMixer(self) -> jneqsim.process.equipment.mixer.Mixer: ...
    def getArrivalStream(self) -> jneqsim.process.equipment.stream.StreamInterface: ...
    def getBranches(self) -> java.util.List['WellFlowlineNetwork.Branch']: ...
    def getManifolds(self) -> java.util.List['WellFlowlineNetwork.ManifoldNode']: ...
    def getTerminalManifoldPressure(self, string: typing.Union[java.lang.String, str]) -> float: ...
    @typing.overload
    def run(self) -> None: ...
    @typing.overload
    def run(self, uUID: java.util.UUID) -> None: ...
    @typing.overload
    def runTransient(self, double: float) -> None: ...
    @typing.overload
    def runTransient(self, double: float, uUID: java.util.UUID) -> None: ...
    def setFacilityPipeline(self, pipeBeggsAndBrills: jneqsim.process.equipment.pipeline.PipeBeggsAndBrills) -> None: ...
    def setForceFlowFromPressureSolve(self, boolean: bool) -> None: ...
    def setIterationTolerance(self, double: float) -> None: ...
    def setMaxIterations(self, int: int) -> None: ...
    def setName(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def setPropagateArrivalPressureToWells(self, boolean: bool) -> None: ...
    def setTargetEndpointPressure(self, double: float, string: typing.Union[java.lang.String, str]) -> None: ...
    @typing.overload
    def toJson(self, reportConfig: jneqsim.process.util.report.ReportConfig) -> java.lang.String: ...
    @typing.overload
    def toJson(self) -> java.lang.String: ...
    class Branch:
        def getChoke(self) -> jneqsim.process.equipment.valve.ThrottlingValve: ...
        def getName(self) -> java.lang.String: ...
        def getPipeline(self) -> jneqsim.process.equipment.pipeline.PipeBeggsAndBrills: ...
        def getWell(self) -> jneqsim.process.equipment.reservoir.WellFlow: ...
        def setChoke(self, throttlingValve: jneqsim.process.equipment.valve.ThrottlingValve) -> None: ...
    class ManifoldNode:
        def getBranches(self) -> java.util.List['WellFlowlineNetwork.Branch']: ...
        def getMixer(self) -> jneqsim.process.equipment.mixer.Mixer: ...
        def getName(self) -> java.lang.String: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.process.equipment.network")``.

    PipeFlowNetwork: typing.Type[PipeFlowNetwork]
    WellFlowlineNetwork: typing.Type[WellFlowlineNetwork]
