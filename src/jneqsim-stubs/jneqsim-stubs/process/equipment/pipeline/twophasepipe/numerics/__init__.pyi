
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import jpype
import typing



class AUSMPlusFluxCalculator(java.io.Serializable):
    def __init__(self): ...
    def calcMachMinus(self, double: float) -> float: ...
    def calcMachPlus(self, double: float) -> float: ...
    def calcPhaseFlux(self, phaseState: 'AUSMPlusFluxCalculator.PhaseState', phaseState2: 'AUSMPlusFluxCalculator.PhaseState', double: float) -> 'AUSMPlusFluxCalculator.PhaseFlux': ...
    def calcPressureMinus(self, double: float) -> float: ...
    def calcPressurePlus(self, double: float) -> float: ...
    def calcRusanovFlux(self, phaseState: 'AUSMPlusFluxCalculator.PhaseState', phaseState2: 'AUSMPlusFluxCalculator.PhaseState', double: float) -> 'AUSMPlusFluxCalculator.PhaseFlux': ...
    def calcTwoFluidFlux(self, phaseState: 'AUSMPlusFluxCalculator.PhaseState', phaseState2: 'AUSMPlusFluxCalculator.PhaseState', phaseState3: 'AUSMPlusFluxCalculator.PhaseState', phaseState4: 'AUSMPlusFluxCalculator.PhaseState', double: float) -> 'AUSMPlusFluxCalculator.TwoFluidFlux': ...
    def calcUpwindFlux(self, phaseState: 'AUSMPlusFluxCalculator.PhaseState', phaseState2: 'AUSMPlusFluxCalculator.PhaseState', double: float) -> 'AUSMPlusFluxCalculator.PhaseFlux': ...
    def getAlpha(self) -> float: ...
    def getBeta(self) -> float: ...
    def getMinSoundSpeed(self) -> float: ...
    def setAlpha(self, double: float) -> None: ...
    def setBeta(self, double: float) -> None: ...
    def setMinSoundSpeed(self, double: float) -> None: ...
    class PhaseFlux(java.io.Serializable):
        massFlux: float = ...
        momentumFlux: float = ...
        energyFlux: float = ...
        holdupFlux: float = ...
        def __init__(self): ...
    class PhaseState(java.io.Serializable):
        density: float = ...
        velocity: float = ...
        pressure: float = ...
        soundSpeed: float = ...
        enthalpy: float = ...
        holdup: float = ...
        @typing.overload
        def __init__(self): ...
        @typing.overload
        def __init__(self, double: float, double2: float, double3: float, double4: float, double5: float, double6: float): ...
    class TwoFluidFlux(java.io.Serializable):
        gasFlux: 'AUSMPlusFluxCalculator.PhaseFlux' = ...
        liquidFlux: 'AUSMPlusFluxCalculator.PhaseFlux' = ...
        interfaceMach: float = ...
        def __init__(self): ...

class MUSCLReconstructor(java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, slopeLimiter: 'MUSCLReconstructor.SlopeLimiter'): ...
    def calcLimitedSlope(self, double: float, double2: float) -> float: ...
    def calcLimiter(self, double: float) -> float: ...
    def getLimiterType(self) -> 'MUSCLReconstructor.SlopeLimiter': ...
    def isSecondOrder(self) -> bool: ...
    def mc(self, double: float) -> float: ...
    def minmod(self, double: float) -> float: ...
    def minmod3(self, double: float, double2: float, double3: float) -> float: ...
    def reconstruct(self, double: float, double2: float, double3: float, double4: float) -> 'MUSCLReconstructor.ReconstructedPair': ...
    def reconstructArray(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> typing.MutableSequence['MUSCLReconstructor.ReconstructedPair']: ...
    def setLimiterType(self, slopeLimiter: 'MUSCLReconstructor.SlopeLimiter') -> None: ...
    def superbee(self, double: float) -> float: ...
    def vanAlbada(self, double: float) -> float: ...
    def vanLeer(self, double: float) -> float: ...
    class ReconstructedPair(java.io.Serializable):
        left: float = ...
        right: float = ...
        def __init__(self): ...
    class SlopeLimiter(java.lang.Enum['MUSCLReconstructor.SlopeLimiter']):
        MINMOD: typing.ClassVar['MUSCLReconstructor.SlopeLimiter'] = ...
        VAN_LEER: typing.ClassVar['MUSCLReconstructor.SlopeLimiter'] = ...
        VAN_ALBADA: typing.ClassVar['MUSCLReconstructor.SlopeLimiter'] = ...
        SUPERBEE: typing.ClassVar['MUSCLReconstructor.SlopeLimiter'] = ...
        MC: typing.ClassVar['MUSCLReconstructor.SlopeLimiter'] = ...
        NONE: typing.ClassVar['MUSCLReconstructor.SlopeLimiter'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'MUSCLReconstructor.SlopeLimiter': ...
        @staticmethod
        def values() -> typing.MutableSequence['MUSCLReconstructor.SlopeLimiter']: ...

class TimeIntegrator(java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, method: 'TimeIntegrator.Method'): ...
    def advanceTime(self, double: float) -> None: ...
    def calcStableTimeStep(self, double: float, double2: float) -> float: ...
    def calcTwoFluidTimeStep(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], doubleArray3: typing.Union[typing.List[float], jpype.JArray], doubleArray4: typing.Union[typing.List[float], jpype.JArray], double5: float) -> float: ...
    def getCflNumber(self) -> float: ...
    def getCurrentDt(self) -> float: ...
    def getCurrentTime(self) -> float: ...
    def getMaxTimeStep(self) -> float: ...
    def getMethod(self) -> 'TimeIntegrator.Method': ...
    def getMinTimeStep(self) -> float: ...
    def reset(self) -> None: ...
    def setCflNumber(self, double: float) -> None: ...
    def setCurrentTime(self, double: float) -> None: ...
    def setMaxTimeStep(self, double: float) -> None: ...
    def setMethod(self, method: 'TimeIntegrator.Method') -> None: ...
    def setMinTimeStep(self, double: float) -> None: ...
    def step(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], rHSFunction: typing.Union['TimeIntegrator.RHSFunction', typing.Callable], double2: float) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def stepEuler(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], rHSFunction: typing.Union['TimeIntegrator.RHSFunction', typing.Callable], double2: float) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def stepRK2(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], rHSFunction: typing.Union['TimeIntegrator.RHSFunction', typing.Callable], double2: float) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def stepRK4(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], rHSFunction: typing.Union['TimeIntegrator.RHSFunction', typing.Callable], double2: float) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def stepSSPRK3(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], rHSFunction: typing.Union['TimeIntegrator.RHSFunction', typing.Callable], double2: float) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    class Method(java.lang.Enum['TimeIntegrator.Method']):
        EULER: typing.ClassVar['TimeIntegrator.Method'] = ...
        RK2: typing.ClassVar['TimeIntegrator.Method'] = ...
        RK4: typing.ClassVar['TimeIntegrator.Method'] = ...
        SSP_RK3: typing.ClassVar['TimeIntegrator.Method'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'TimeIntegrator.Method': ...
        @staticmethod
        def values() -> typing.MutableSequence['TimeIntegrator.Method']: ...
    class RHSFunction:
        def evaluate(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], double2: float) -> typing.MutableSequence[typing.MutableSequence[float]]: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.process.equipment.pipeline.twophasepipe.numerics")``.

    AUSMPlusFluxCalculator: typing.Type[AUSMPlusFluxCalculator]
    MUSCLReconstructor: typing.Type[MUSCLReconstructor]
    TimeIntegrator: typing.Type[TimeIntegrator]
