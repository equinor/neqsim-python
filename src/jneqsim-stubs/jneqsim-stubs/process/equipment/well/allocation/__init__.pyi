import sys

if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.time
import java.util
import jneqsim.process.equipment.stream
import typing

class AllocationResult(java.io.Serializable):
    def __init__(
        self,
        map: typing.Union[
            java.util.Map[typing.Union[java.lang.String, str], float],
            typing.Mapping[typing.Union[java.lang.String, str], float],
        ],
        map2: typing.Union[
            java.util.Map[typing.Union[java.lang.String, str], float],
            typing.Mapping[typing.Union[java.lang.String, str], float],
        ],
        map3: typing.Union[
            java.util.Map[typing.Union[java.lang.String, str], float],
            typing.Mapping[typing.Union[java.lang.String, str], float],
        ],
        map4: typing.Union[
            java.util.Map[typing.Union[java.lang.String, str], float],
            typing.Mapping[typing.Union[java.lang.String, str], float],
        ],
        double: float,
    ): ...
    def getAllGasRates(self) -> java.util.Map[java.lang.String, float]: ...
    def getAllOilRates(self) -> java.util.Map[java.lang.String, float]: ...
    def getAllWaterRates(self) -> java.util.Map[java.lang.String, float]: ...
    def getAllocationError(self) -> float: ...
    def getGOR(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getGasRate(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getOilRate(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getTimestamp(self) -> java.time.Instant: ...
    def getTotalGasRate(self) -> float: ...
    def getTotalOilRate(self) -> float: ...
    def getTotalWaterRate(self) -> float: ...
    def getUncertainty(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getWaterCut(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getWaterRate(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getWellAllocation(
        self, string: typing.Union[java.lang.String, str]
    ) -> java.util.Map[java.lang.String, float]: ...
    def getWellNames(self) -> typing.MutableSequence[java.lang.String]: ...
    def isBalanced(self) -> bool: ...
    def toString(self) -> java.lang.String: ...

class WellProductionAllocator(java.io.Serializable):
    def __init__(self, string: typing.Union[java.lang.String, str]): ...
    def addWell(
        self, string: typing.Union[java.lang.String, str]
    ) -> "WellProductionAllocator.WellData": ...
    def allocate(
        self, double: float, double2: float, double3: float
    ) -> AllocationResult: ...
    def getName(self) -> java.lang.String: ...
    def getWell(
        self, string: typing.Union[java.lang.String, str]
    ) -> "WellProductionAllocator.WellData": ...
    def getWellCount(self) -> int: ...
    def getWellNames(self) -> java.util.List[java.lang.String]: ...
    def setAllocationMethod(
        self, allocationMethod: "WellProductionAllocator.AllocationMethod"
    ) -> None: ...
    def setReconciliationTolerance(self, double: float) -> None: ...

    class AllocationMethod(java.lang.Enum["WellProductionAllocator.AllocationMethod"]):
        WELL_TEST: typing.ClassVar["WellProductionAllocator.AllocationMethod"] = ...
        VFM_BASED: typing.ClassVar["WellProductionAllocator.AllocationMethod"] = ...
        CHOKE_MODEL: typing.ClassVar["WellProductionAllocator.AllocationMethod"] = ...
        COMBINED: typing.ClassVar["WellProductionAllocator.AllocationMethod"] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: typing.Type[_valueOf_0__T],
            string: typing.Union[java.lang.String, str],
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(
            string: typing.Union[java.lang.String, str]
        ) -> "WellProductionAllocator.AllocationMethod": ...
        @staticmethod
        def values() -> (
            typing.MutableSequence["WellProductionAllocator.AllocationMethod"]
        ): ...

    class WellData(java.io.Serializable):
        def __init__(self, string: typing.Union[java.lang.String, str]): ...
        def getChokePosition(self) -> float: ...
        def getProductivityIndex(self) -> float: ...
        def getReservoirPressure(self) -> float: ...
        def getTestGasRate(self) -> float: ...
        def getTestOilRate(self) -> float: ...
        def getTestWaterRate(self) -> float: ...
        def getVfmGasRate(self) -> float: ...
        def getVfmOilRate(self) -> float: ...
        def getVfmWaterRate(self) -> float: ...
        def getWeight(self) -> float: ...
        def getWellName(self) -> java.lang.String: ...
        def getWellStream(self) -> jneqsim.process.equipment.stream.StreamInterface: ...
        def setChokePosition(self, double: float) -> None: ...
        def setProductivityIndex(self, double: float) -> None: ...
        def setReservoirPressure(self, double: float) -> None: ...
        def setTestRates(
            self, double: float, double2: float, double3: float
        ) -> None: ...
        def setVFMRates(
            self, double: float, double2: float, double3: float
        ) -> None: ...
        def setWeight(self, double: float) -> None: ...
        def setWellStream(
            self, streamInterface: jneqsim.process.equipment.stream.StreamInterface
        ) -> None: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.process.equipment.well.allocation")``.

    AllocationResult: typing.Type[AllocationResult]
    WellProductionAllocator: typing.Type[WellProductionAllocator]
