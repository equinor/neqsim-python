import sys

if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import datetime
import java.io
import java.lang
import java.time
import java.util
import java.util.function
import jneqsim.process.processmodel
import typing

class StreamingDataInterface:
    def clearHistory(self) -> None: ...
    def getCurrentValue(
        self, string: typing.Union[java.lang.String, str]
    ) -> "TimestampedValue": ...
    def getHistory(
        self, string: typing.Union[java.lang.String, str], duration: java.time.Duration
    ) -> java.util.List["TimestampedValue"]: ...
    def getHistoryBatch(
        self,
        list: java.util.List[typing.Union[java.lang.String, str]],
        duration: java.time.Duration,
    ) -> java.util.Map[java.lang.String, java.util.List["TimestampedValue"]]: ...
    def getMonitoredTags(self) -> java.util.List[java.lang.String]: ...
    def getStateVector(self) -> typing.MutableSequence[float]: ...
    def getStateVectorLabels(self) -> typing.MutableSequence[java.lang.String]: ...
    def isMonitored(self, string: typing.Union[java.lang.String, str]) -> bool: ...
    def publish(
        self,
        string: typing.Union[java.lang.String, str],
        timestampedValue: "TimestampedValue",
    ) -> None: ...
    def publishBatch(
        self,
        map: typing.Union[
            java.util.Map[typing.Union[java.lang.String, str], "TimestampedValue"],
            typing.Mapping[typing.Union[java.lang.String, str], "TimestampedValue"],
        ],
    ) -> None: ...
    def setHistoryBufferSize(self, int: int) -> None: ...
    def subscribeToUpdates(
        self,
        string: typing.Union[java.lang.String, str],
        consumer: typing.Union[
            java.util.function.Consumer["TimestampedValue"],
            typing.Callable[["TimestampedValue"], None],
        ],
    ) -> None: ...
    def unsubscribeFromUpdates(
        self, string: typing.Union[java.lang.String, str]
    ) -> None: ...

class TimestampedValue(java.io.Serializable):
    @typing.overload
    def __init__(self, double: float, string: typing.Union[java.lang.String, str]): ...
    @typing.overload
    def __init__(
        self,
        double: float,
        string: typing.Union[java.lang.String, str],
        instant: typing.Union[java.time.Instant, datetime.datetime],
    ): ...
    @typing.overload
    def __init__(
        self,
        double: float,
        string: typing.Union[java.lang.String, str],
        instant: typing.Union[java.time.Instant, datetime.datetime],
        quality: "TimestampedValue.Quality",
    ): ...
    def getQuality(self) -> "TimestampedValue.Quality": ...
    def getTimestamp(self) -> java.time.Instant: ...
    def getUnit(self) -> java.lang.String: ...
    def getValue(self) -> float: ...
    def isUsable(self) -> bool: ...
    @staticmethod
    def simulated(
        double: float, string: typing.Union[java.lang.String, str]
    ) -> "TimestampedValue": ...
    def toString(self) -> java.lang.String: ...

    class Quality(java.lang.Enum["TimestampedValue.Quality"]):
        GOOD: typing.ClassVar["TimestampedValue.Quality"] = ...
        UNCERTAIN: typing.ClassVar["TimestampedValue.Quality"] = ...
        BAD: typing.ClassVar["TimestampedValue.Quality"] = ...
        SIMULATED: typing.ClassVar["TimestampedValue.Quality"] = ...
        ESTIMATED: typing.ClassVar["TimestampedValue.Quality"] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: typing.Type[_valueOf_0__T],
            string: typing.Union[java.lang.String, str],
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(
            string: typing.Union[java.lang.String, str]
        ) -> "TimestampedValue.Quality": ...
        @staticmethod
        def values() -> typing.MutableSequence["TimestampedValue.Quality"]: ...

class ProcessDataPublisher(StreamingDataInterface):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, processSystem: jneqsim.process.processmodel.ProcessSystem): ...
    def addToStateVector(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def clearHistory(self) -> None: ...
    def exportHistoryMatrix(
        self, list: java.util.List[typing.Union[java.lang.String, str]]
    ) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def getCurrentValue(
        self, string: typing.Union[java.lang.String, str]
    ) -> TimestampedValue: ...
    def getHistory(
        self, string: typing.Union[java.lang.String, str], duration: java.time.Duration
    ) -> java.util.List[TimestampedValue]: ...
    def getHistoryBatch(
        self,
        list: java.util.List[typing.Union[java.lang.String, str]],
        duration: java.time.Duration,
    ) -> java.util.Map[java.lang.String, java.util.List[TimestampedValue]]: ...
    def getHistorySize(self, string: typing.Union[java.lang.String, str]) -> int: ...
    def getMonitoredTags(self) -> java.util.List[java.lang.String]: ...
    def getStateVector(self) -> typing.MutableSequence[float]: ...
    def getStateVectorLabels(self) -> typing.MutableSequence[java.lang.String]: ...
    def isMonitored(self, string: typing.Union[java.lang.String, str]) -> bool: ...
    def publishBatch(
        self,
        map: typing.Union[
            java.util.Map[typing.Union[java.lang.String, str], TimestampedValue],
            typing.Mapping[typing.Union[java.lang.String, str], TimestampedValue],
        ],
    ) -> None: ...
    def publishFromProcessSystem(self) -> None: ...
    def setHistoryBufferSize(self, int: int) -> None: ...
    def setProcessSystem(
        self, processSystem: jneqsim.process.processmodel.ProcessSystem
    ) -> None: ...
    def subscribeToUpdates(
        self,
        string: typing.Union[java.lang.String, str],
        consumer: typing.Union[
            java.util.function.Consumer[TimestampedValue],
            typing.Callable[[TimestampedValue], None],
        ],
    ) -> None: ...
    def unsubscribeFromUpdates(
        self, string: typing.Union[java.lang.String, str]
    ) -> None: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.process.streaming")``.

    ProcessDataPublisher: typing.Type[ProcessDataPublisher]
    StreamingDataInterface: typing.Type[StreamingDataInterface]
    TimestampedValue: typing.Type[TimestampedValue]
