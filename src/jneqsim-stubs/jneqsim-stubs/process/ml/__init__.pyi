import sys

if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.util
import java.util.function
import jpype
import jneqsim.process.equipment
import jneqsim.process.equipment.separator
import jneqsim.process.ml.controllers
import jneqsim.process.ml.examples
import jneqsim.process.ml.multiagent
import jneqsim.process.ml.surrogate
import jneqsim.process.processmodel
import typing

class ActionVector(java.io.Serializable):
    def __init__(self): ...
    def define(
        self,
        string: typing.Union[java.lang.String, str],
        double: float,
        double2: float,
        string2: typing.Union[java.lang.String, str],
    ) -> "ActionVector": ...
    def get(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getActionNames(self) -> typing.MutableSequence[java.lang.String]: ...
    def getLowerBounds(self) -> typing.MutableSequence[float]: ...
    def getUpperBounds(self) -> typing.MutableSequence[float]: ...
    def isAtBound(self, string: typing.Union[java.lang.String, str]) -> bool: ...
    def set(
        self, string: typing.Union[java.lang.String, str], double: float
    ) -> "ActionVector": ...
    def setFromNormalizedArray(
        self, doubleArray: typing.Union[typing.List[float], jpype.JArray]
    ) -> "ActionVector": ...
    def setNormalized(
        self, string: typing.Union[java.lang.String, str], double: float
    ) -> "ActionVector": ...
    def size(self) -> int: ...
    def toArray(self) -> typing.MutableSequence[float]: ...
    def toString(self) -> java.lang.String: ...

class Constraint(java.io.Serializable):
    def __init__(
        self,
        string: typing.Union[java.lang.String, str],
        string2: typing.Union[java.lang.String, str],
        type: "Constraint.Type",
        category: "Constraint.Category",
        string3: typing.Union[java.lang.String, str],
        double: float,
        double2: float,
        string4: typing.Union[java.lang.String, str],
    ): ...
    def evaluate(self, double: float) -> "Constraint": ...
    def getCategory(self) -> "Constraint.Category": ...
    def getCurrentValue(self) -> float: ...
    def getDescription(self) -> java.lang.String: ...
    def getLowerBound(self) -> float: ...
    def getMargin(self) -> float: ...
    def getName(self) -> java.lang.String: ...
    def getNormalizedViolation(self) -> float: ...
    def getType(self) -> "Constraint.Type": ...
    def getUnit(self) -> java.lang.String: ...
    def getUpperBound(self) -> float: ...
    def getVariableName(self) -> java.lang.String: ...
    def getViolation(self) -> float: ...
    def isHard(self) -> bool: ...
    def isViolated(self) -> bool: ...
    @staticmethod
    def lowerBound(
        string: typing.Union[java.lang.String, str],
        string2: typing.Union[java.lang.String, str],
        double: float,
        string3: typing.Union[java.lang.String, str],
        type: "Constraint.Type",
    ) -> "Constraint": ...
    def project(self, double: float) -> float: ...
    @staticmethod
    def range(
        string: typing.Union[java.lang.String, str],
        string2: typing.Union[java.lang.String, str],
        double: float,
        double2: float,
        string3: typing.Union[java.lang.String, str],
        type: "Constraint.Type",
    ) -> "Constraint": ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def upperBound(
        string: typing.Union[java.lang.String, str],
        string2: typing.Union[java.lang.String, str],
        double: float,
        string3: typing.Union[java.lang.String, str],
        type: "Constraint.Type",
    ) -> "Constraint": ...

    class Category(java.lang.Enum["Constraint.Category"]):
        PHYSICAL: typing.ClassVar["Constraint.Category"] = ...
        SAFETY: typing.ClassVar["Constraint.Category"] = ...
        EQUIPMENT: typing.ClassVar["Constraint.Category"] = ...
        OPERATIONAL: typing.ClassVar["Constraint.Category"] = ...
        ECONOMIC: typing.ClassVar["Constraint.Category"] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: typing.Type[_valueOf_0__T],
            string: typing.Union[java.lang.String, str],
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(
            string: typing.Union[java.lang.String, str]
        ) -> "Constraint.Category": ...
        @staticmethod
        def values() -> typing.MutableSequence["Constraint.Category"]: ...

    class Type(java.lang.Enum["Constraint.Type"]):
        HARD: typing.ClassVar["Constraint.Type"] = ...
        SOFT: typing.ClassVar["Constraint.Type"] = ...
        INFO: typing.ClassVar["Constraint.Type"] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: typing.Type[_valueOf_0__T],
            string: typing.Union[java.lang.String, str],
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(
            string: typing.Union[java.lang.String, str]
        ) -> "Constraint.Type": ...
        @staticmethod
        def values() -> typing.MutableSequence["Constraint.Type"]: ...

class ConstraintManager(java.io.Serializable):
    def __init__(self): ...
    def add(self, constraint: Constraint) -> "ConstraintManager": ...
    def addHardLowerBound(
        self,
        string: typing.Union[java.lang.String, str],
        string2: typing.Union[java.lang.String, str],
        double: float,
        string3: typing.Union[java.lang.String, str],
    ) -> "ConstraintManager": ...
    def addHardRange(
        self,
        string: typing.Union[java.lang.String, str],
        string2: typing.Union[java.lang.String, str],
        double: float,
        double2: float,
        string3: typing.Union[java.lang.String, str],
    ) -> "ConstraintManager": ...
    def addHardUpperBound(
        self,
        string: typing.Union[java.lang.String, str],
        string2: typing.Union[java.lang.String, str],
        double: float,
        string3: typing.Union[java.lang.String, str],
    ) -> "ConstraintManager": ...
    def addSoftRange(
        self,
        string: typing.Union[java.lang.String, str],
        string2: typing.Union[java.lang.String, str],
        double: float,
        double2: float,
        string3: typing.Union[java.lang.String, str],
    ) -> "ConstraintManager": ...
    def addViolationListener(
        self,
        constraintViolationListener: typing.Union[
            "ConstraintManager.ConstraintViolationListener", typing.Callable
        ],
    ) -> None: ...
    def clear(self) -> None: ...
    def evaluate(self, stateVector: "StateVector") -> java.util.List[Constraint]: ...
    def explainViolations(self) -> java.lang.String: ...
    def get(self, string: typing.Union[java.lang.String, str]) -> Constraint: ...
    def getAll(self) -> java.util.List[Constraint]: ...
    def getMinHardMargin(self) -> float: ...
    def getTotalViolationPenalty(self) -> float: ...
    def getViolations(self) -> java.util.List[Constraint]: ...
    def getViolationsByCategory(
        self, category: Constraint.Category
    ) -> java.util.List[Constraint]: ...
    def hasHardViolation(self) -> bool: ...
    def size(self) -> int: ...
    def toString(self) -> java.lang.String: ...

    class ConstraintViolationListener:
        def onViolation(self, constraint: Constraint) -> None: ...

class EpisodeRunner(java.io.Serializable):
    def __init__(self, gymEnvironment: "GymEnvironment"): ...
    def benchmark(
        self, controller: jneqsim.process.ml.controllers.Controller, int: int, int2: int
    ) -> "EpisodeRunner.BenchmarkResult": ...
    def compareControllers(
        self,
        list: java.util.List[jneqsim.process.ml.controllers.Controller],
        int: int,
        int2: int,
    ) -> java.util.List["EpisodeRunner.BenchmarkResult"]: ...
    @staticmethod
    def printComparison(
        list: java.util.List["EpisodeRunner.BenchmarkResult"],
    ) -> None: ...
    def runEpisode(
        self, controller: jneqsim.process.ml.controllers.Controller, int: int
    ) -> "EpisodeRunner.EpisodeResult": ...
    def setPrintInterval(self, int: int) -> "EpisodeRunner": ...
    def setVerbose(self, boolean: bool) -> "EpisodeRunner": ...

    class BenchmarkResult(java.io.Serializable):
        controllerName: java.lang.String = ...
        numEpisodes: int = ...
        meanReward: float = ...
        stdReward: float = ...
        meanLength: float = ...
        successRate: float = ...
        minReward: float = ...
        maxReward: float = ...
        def __init__(
            self,
            string: typing.Union[java.lang.String, str],
            int: int,
            double: float,
            double2: float,
            double3: float,
            double4: float,
            double5: float,
            double6: float,
        ): ...
        def toString(self) -> java.lang.String: ...

    class EpisodeResult(java.io.Serializable):
        totalReward: float = ...
        steps: int = ...
        terminated: bool = ...
        observations: java.util.List = ...
        actions: java.util.List = ...
        rewards: java.util.List = ...
        finalObservation: typing.MutableSequence[float] = ...
        def __init__(
            self,
            double: float,
            int: int,
            boolean: bool,
            list: java.util.List[typing.Union[typing.List[float], jpype.JArray]],
            list2: java.util.List[typing.Union[typing.List[float], jpype.JArray]],
            list3: java.util.List[float],
            doubleArray: typing.Union[typing.List[float], jpype.JArray],
        ): ...
        def getFeatureTrajectory(self, int: int) -> typing.MutableSequence[float]: ...
        def getMeanReward(self) -> float: ...
        def getObservation(self, int: int, int2: int) -> float: ...

class EquipmentStateAdapter(java.io.Serializable):
    def __init__(
        self,
        processEquipmentInterface: jneqsim.process.equipment.ProcessEquipmentInterface,
    ): ...
    @staticmethod
    def forSeparator(
        separatorInterface: jneqsim.process.equipment.separator.SeparatorInterface,
    ) -> "EquipmentStateAdapter": ...
    def getEquipment(self) -> jneqsim.process.equipment.ProcessEquipmentInterface: ...
    def getStateVector(self) -> "StateVector": ...
    def setCustomExtractor(
        self,
        function: typing.Union[
            java.util.function.Function[
                jneqsim.process.equipment.ProcessEquipmentInterface, "StateVector"
            ],
            typing.Callable[
                [jneqsim.process.equipment.ProcessEquipmentInterface], "StateVector"
            ],
        ],
    ) -> "EquipmentStateAdapter": ...

class GymEnvironment(java.io.Serializable):
    def __init__(self): ...
    def getActionDim(self) -> int: ...
    def getActionHigh(self) -> typing.MutableSequence[float]: ...
    def getActionLow(self) -> typing.MutableSequence[float]: ...
    def getCurrentStep(self) -> int: ...
    def getEnvId(self) -> java.lang.String: ...
    def getEpisodeReward(self) -> float: ...
    def getMaxEpisodeSteps(self) -> int: ...
    def getObservationDim(self) -> int: ...
    def getObservationHigh(self) -> typing.MutableSequence[float]: ...
    def getObservationLow(self) -> typing.MutableSequence[float]: ...
    def isDone(self) -> bool: ...
    @typing.overload
    def reset(self) -> "GymEnvironment.ResetResult": ...
    @typing.overload
    def reset(
        self,
        long: int,
        map: typing.Union[
            java.util.Map[typing.Union[java.lang.String, str], typing.Any],
            typing.Mapping[typing.Union[java.lang.String, str], typing.Any],
        ],
    ) -> "GymEnvironment.ResetResult": ...
    def setMaxEpisodeSteps(self, int: int) -> None: ...
    def step(
        self, doubleArray: typing.Union[typing.List[float], jpype.JArray]
    ) -> "GymEnvironment.StepResult": ...

    class ResetResult(java.io.Serializable):
        observation: typing.MutableSequence[float] = ...
        info: java.util.Map = ...
        def __init__(
            self,
            doubleArray: typing.Union[typing.List[float], jpype.JArray],
            map: typing.Union[
                java.util.Map[typing.Union[java.lang.String, str], typing.Any],
                typing.Mapping[typing.Union[java.lang.String, str], typing.Any],
            ],
        ): ...

    class StepResult(java.io.Serializable):
        observation: typing.MutableSequence[float] = ...
        reward: float = ...
        terminated: bool = ...
        truncated: bool = ...
        info: java.util.Map = ...
        def __init__(
            self,
            doubleArray: typing.Union[typing.List[float], jpype.JArray],
            double2: float,
            boolean: bool,
            boolean2: bool,
            map: typing.Union[
                java.util.Map[typing.Union[java.lang.String, str], typing.Any],
                typing.Mapping[typing.Union[java.lang.String, str], typing.Any],
            ],
        ): ...

class RLEnvironment(java.io.Serializable):
    def __init__(self, processSystem: jneqsim.process.processmodel.ProcessSystem): ...
    def addConstraint(
        self,
        string: typing.Union[java.lang.String, str],
        string2: typing.Union[java.lang.String, str],
        double: float,
        double2: float,
        string3: typing.Union[java.lang.String, str],
    ) -> "RLEnvironment": ...
    def defineAction(
        self,
        string: typing.Union[java.lang.String, str],
        double: float,
        double2: float,
        string2: typing.Union[java.lang.String, str],
    ) -> "RLEnvironment": ...
    def getActionSpace(self) -> ActionVector: ...
    def getConstraintManager(self) -> ConstraintManager: ...
    def getCurrentTime(self) -> float: ...
    def getProcess(self) -> jneqsim.process.processmodel.ProcessSystem: ...
    def getStepCount(self) -> int: ...
    def isDone(self) -> bool: ...
    def reset(self) -> "StateVector": ...
    def setMaxEpisodeTime(self, double: float) -> "RLEnvironment": ...
    def setRewardWeights(
        self, double: float, double2: float, double3: float, double4: float
    ) -> "RLEnvironment": ...
    def setTimeStep(self, double: float) -> "RLEnvironment": ...
    def step(self, actionVector: ActionVector) -> "RLEnvironment.StepResult": ...

    class StepInfo(java.io.Serializable):
        constraintPenalty: float = ...
        energyConsumption: float = ...
        throughput: float = ...
        simulationTime: float = ...
        hardViolation: bool = ...
        violationExplanation: java.lang.String = ...
        def __init__(self): ...

    class StepResult(java.io.Serializable):
        observation: "StateVector" = ...
        reward: float = ...
        done: bool = ...
        truncated: bool = ...
        info: "RLEnvironment.StepInfo" = ...
        def __init__(
            self,
            stateVector: "StateVector",
            double: float,
            boolean: bool,
            boolean2: bool,
            stepInfo: "RLEnvironment.StepInfo",
        ): ...

class StateVector(java.io.Serializable):
    def __init__(self): ...
    @typing.overload
    def add(
        self,
        string: typing.Union[java.lang.String, str],
        double: float,
        double2: float,
        double3: float,
        string2: typing.Union[java.lang.String, str],
    ) -> "StateVector": ...
    @typing.overload
    def add(
        self,
        string: typing.Union[java.lang.String, str],
        double: float,
        string2: typing.Union[java.lang.String, str],
    ) -> "StateVector": ...
    def getFeatureNames(self) -> typing.MutableSequence[java.lang.String]: ...
    def getLowerBounds(self) -> typing.MutableSequence[float]: ...
    def getNormalized(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getTimestampMs(self) -> int: ...
    def getUpperBounds(self) -> typing.MutableSequence[float]: ...
    def getValue(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def size(self) -> int: ...
    def toArray(self) -> typing.MutableSequence[float]: ...
    def toMap(self) -> java.util.Map[java.lang.String, typing.Any]: ...
    def toNormalizedArray(self) -> typing.MutableSequence[float]: ...
    def toString(self) -> java.lang.String: ...

class StateVectorProvider:
    def getStateDimension(self) -> int: ...
    def getStateNames(self) -> typing.MutableSequence[java.lang.String]: ...
    def getStateVector(self) -> StateVector: ...

class TrainingDataCollector(java.io.Serializable):
    def __init__(self, string: typing.Union[java.lang.String, str]): ...
    def clear(self) -> None: ...
    def defineInput(
        self,
        string: typing.Union[java.lang.String, str],
        string2: typing.Union[java.lang.String, str],
        double: float,
        double2: float,
    ) -> "TrainingDataCollector": ...
    def defineOutput(
        self,
        string: typing.Union[java.lang.String, str],
        string2: typing.Union[java.lang.String, str],
        double: float,
        double2: float,
    ) -> "TrainingDataCollector": ...
    def endSample(self) -> None: ...
    def exportCSV(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def getInputStatistics(
        self,
    ) -> java.util.Map[java.lang.String, java.util.Map[java.lang.String, float]]: ...
    def getName(self) -> java.lang.String: ...
    def getOutputStatistics(
        self,
    ) -> java.util.Map[java.lang.String, java.util.Map[java.lang.String, float]]: ...
    def getSampleCount(self) -> int: ...
    def getSummary(self) -> java.lang.String: ...
    def recordInput(
        self, string: typing.Union[java.lang.String, str], double: float
    ) -> None: ...
    def recordOutput(
        self, string: typing.Union[java.lang.String, str], double: float
    ) -> None: ...
    def recordStateAsInputs(self, stateVector: StateVector) -> None: ...
    def recordStateAsOutputs(self, stateVector: StateVector) -> None: ...
    def startSample(self) -> None: ...
    def toCSV(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.process.ml")``.

    ActionVector: typing.Type[ActionVector]
    Constraint: typing.Type[Constraint]
    ConstraintManager: typing.Type[ConstraintManager]
    EpisodeRunner: typing.Type[EpisodeRunner]
    EquipmentStateAdapter: typing.Type[EquipmentStateAdapter]
    GymEnvironment: typing.Type[GymEnvironment]
    RLEnvironment: typing.Type[RLEnvironment]
    StateVector: typing.Type[StateVector]
    StateVectorProvider: typing.Type[StateVectorProvider]
    TrainingDataCollector: typing.Type[TrainingDataCollector]
    controllers: jneqsim.process.ml.controllers.__module_protocol__
    examples: jneqsim.process.ml.examples.__module_protocol__
    multiagent: jneqsim.process.ml.multiagent.__module_protocol__
    surrogate: jneqsim.process.ml.surrogate.__module_protocol__
