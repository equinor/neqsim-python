
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import datetime
import java.io
import java.lang
import java.time
import java.util
import java.util.function
import jpype
import jneqsim.process.processmodel
import typing



class PhysicsConstraintValidator(java.io.Serializable):
    def __init__(self, processSystem: jneqsim.process.processmodel.ProcessSystem): ...
    def addFlowLimit(self, string: typing.Union[java.lang.String, str], double: float, double2: float, string2: typing.Union[java.lang.String, str]) -> None: ...
    def addPressureLimit(self, string: typing.Union[java.lang.String, str], double: float, double2: float, string2: typing.Union[java.lang.String, str]) -> None: ...
    def addTemperatureLimit(self, string: typing.Union[java.lang.String, str], double: float, double2: float, string2: typing.Union[java.lang.String, str]) -> None: ...
    def isEnforceEnergyBalance(self) -> bool: ...
    def isEnforceMassBalance(self) -> bool: ...
    def isEnforcePhysicalBounds(self) -> bool: ...
    def setEnergyBalanceTolerance(self, double: float) -> None: ...
    def setEnforceEnergyBalance(self, boolean: bool) -> None: ...
    def setEnforceMassBalance(self, boolean: bool) -> None: ...
    def setEnforcePhysicalBounds(self, boolean: bool) -> None: ...
    def setMassBalanceTolerance(self, double: float) -> None: ...
    def validate(self, map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]]) -> 'PhysicsConstraintValidator.ValidationResult': ...
    def validateCurrentState(self) -> 'PhysicsConstraintValidator.ValidationResult': ...
    class ConstraintViolation(java.io.Serializable):
        def __init__(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], double: float, string3: typing.Union[java.lang.String, str]): ...
        def getConstraintName(self) -> java.lang.String: ...
        def getMessage(self) -> java.lang.String: ...
        def getValue(self) -> float: ...
        def getVariable(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class ValidationResult(java.io.Serializable):
        def __init__(self): ...
        def getRejectionReason(self) -> java.lang.String: ...
        def getViolations(self) -> java.util.List['PhysicsConstraintValidator.ConstraintViolation']: ...
        def isValid(self) -> bool: ...

class SurrogateModelRegistry(java.io.Serializable):
    def clear(self) -> None: ...
    def get(self, string: typing.Union[java.lang.String, str]) -> java.util.Optional['SurrogateModelRegistry.SurrogateModel']: ...
    def getAllModels(self) -> java.util.Map[java.lang.String, 'SurrogateModelRegistry.SurrogateMetadata']: ...
    @staticmethod
    def getInstance() -> 'SurrogateModelRegistry': ...
    def getMetadata(self, string: typing.Union[java.lang.String, str]) -> java.util.Optional['SurrogateModelRegistry.SurrogateMetadata']: ...
    def getPersistenceDirectory(self) -> java.lang.String: ...
    def hasModel(self, string: typing.Union[java.lang.String, str]) -> bool: ...
    def isEnableFallback(self) -> bool: ...
    def loadModel(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> None: ...
    def predictWithFallback(self, string: typing.Union[java.lang.String, str], doubleArray: typing.Union[typing.List[float], jpype.JArray], function: typing.Union[java.util.function.Function[typing.Union[typing.List[float], jpype.JArray], typing.Union[typing.List[float], jpype.JArray]], typing.Callable[[typing.Union[typing.List[float], jpype.JArray]], typing.Union[typing.List[float], jpype.JArray]]]) -> typing.MutableSequence[float]: ...
    @typing.overload
    def register(self, string: typing.Union[java.lang.String, str], surrogateModel: typing.Union['SurrogateModelRegistry.SurrogateModel', typing.Callable]) -> None: ...
    @typing.overload
    def register(self, string: typing.Union[java.lang.String, str], surrogateModel: typing.Union['SurrogateModelRegistry.SurrogateModel', typing.Callable], surrogateMetadata: 'SurrogateModelRegistry.SurrogateMetadata') -> None: ...
    def saveModel(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> None: ...
    def setEnableFallback(self, boolean: bool) -> None: ...
    def setPersistenceDirectory(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def unregister(self, string: typing.Union[java.lang.String, str]) -> bool: ...
    class SurrogateMetadata(java.io.Serializable):
        def __init__(self): ...
        def getExpectedAccuracy(self) -> float: ...
        def getExtrapolationRate(self) -> float: ...
        def getFailureCount(self) -> int: ...
        def getFailureRate(self) -> float: ...
        def getLastUsed(self) -> java.time.Instant: ...
        def getModelType(self) -> java.lang.String: ...
        def getPredictionCount(self) -> int: ...
        def getTrainedAt(self) -> java.time.Instant: ...
        def getTrainingDataSource(self) -> java.lang.String: ...
        def isInputValid(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> bool: ...
        def setExpectedAccuracy(self, double: float) -> None: ...
        def setInputBounds(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
        def setModelType(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setTrainedAt(self, instant: typing.Union[java.time.Instant, datetime.datetime]) -> None: ...
        def setTrainingDataSource(self, string: typing.Union[java.lang.String, str]) -> None: ...
    class SurrogateModel(java.io.Serializable):
        def getInputDimension(self) -> int: ...
        def getOutputDimension(self) -> int: ...
        def predict(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> typing.MutableSequence[float]: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.process.ml.surrogate")``.

    PhysicsConstraintValidator: typing.Type[PhysicsConstraintValidator]
    SurrogateModelRegistry: typing.Type[SurrogateModelRegistry]
