import sys

if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import datetime
import java.io
import java.lang
import java.time
import java.util
import jneqsim.process.equipment.stream
import jneqsim.process.measurementdevice
import typing

class SoftSensor(jneqsim.process.measurementdevice.StreamMeasurementDeviceBaseClass):
    def __init__(
        self,
        string: typing.Union[java.lang.String, str],
        streamInterface: jneqsim.process.equipment.stream.StreamInterface,
        propertyType: "SoftSensor.PropertyType",
    ): ...
    @typing.overload
    def estimate(self) -> float: ...
    @typing.overload
    def estimate(
        self,
        map: typing.Union[
            java.util.Map[typing.Union[java.lang.String, str], float],
            typing.Mapping[typing.Union[java.lang.String, str], float],
        ],
    ) -> float: ...
    def getLastSensitivity(self) -> typing.MutableSequence[float]: ...
    @typing.overload
    def getMeasuredValue(self) -> float: ...
    @typing.overload
    def getMeasuredValue(
        self, string: typing.Union[java.lang.String, str]
    ) -> float: ...
    def getPropertyType(self) -> "SoftSensor.PropertyType": ...
    def getSensitivity(self) -> typing.MutableSequence[float]: ...
    def getUncertaintyBounds(
        self, double: float, double2: float
    ) -> "UncertaintyBounds": ...
    def setInput(
        self, string: typing.Union[java.lang.String, str], double: float
    ) -> None: ...
    def setInputs(
        self,
        map: typing.Union[
            java.util.Map[typing.Union[java.lang.String, str], float],
            typing.Mapping[typing.Union[java.lang.String, str], float],
        ],
    ) -> None: ...
    def setPropertyType(self, propertyType: "SoftSensor.PropertyType") -> None: ...

    class PropertyType(java.lang.Enum["SoftSensor.PropertyType"]):
        GOR: typing.ClassVar["SoftSensor.PropertyType"] = ...
        WATER_CUT: typing.ClassVar["SoftSensor.PropertyType"] = ...
        DENSITY: typing.ClassVar["SoftSensor.PropertyType"] = ...
        OIL_VISCOSITY: typing.ClassVar["SoftSensor.PropertyType"] = ...
        GAS_VISCOSITY: typing.ClassVar["SoftSensor.PropertyType"] = ...
        Z_FACTOR: typing.ClassVar["SoftSensor.PropertyType"] = ...
        HEATING_VALUE: typing.ClassVar["SoftSensor.PropertyType"] = ...
        BUBBLE_POINT: typing.ClassVar["SoftSensor.PropertyType"] = ...
        DEW_POINT: typing.ClassVar["SoftSensor.PropertyType"] = ...
        OIL_FVF: typing.ClassVar["SoftSensor.PropertyType"] = ...
        GAS_FVF: typing.ClassVar["SoftSensor.PropertyType"] = ...
        SOLUTION_GOR: typing.ClassVar["SoftSensor.PropertyType"] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: typing.Type[_valueOf_0__T],
            string: typing.Union[java.lang.String, str],
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(
            string: typing.Union[java.lang.String, str]
        ) -> "SoftSensor.PropertyType": ...
        @staticmethod
        def values() -> typing.MutableSequence["SoftSensor.PropertyType"]: ...

class UncertaintyBounds(java.io.Serializable):
    @typing.overload
    def __init__(
        self,
        double: float,
        double2: float,
        double3: float,
        double4: float,
        double5: float,
        double6: float,
        string: typing.Union[java.lang.String, str],
    ): ...
    @typing.overload
    def __init__(
        self, double: float, double2: float, string: typing.Union[java.lang.String, str]
    ): ...
    def add(self, uncertaintyBounds: "UncertaintyBounds") -> "UncertaintyBounds": ...
    def getCoefficientOfVariation(self) -> float: ...
    def getLower95(self) -> float: ...
    def getLower99(self) -> float: ...
    def getMean(self) -> float: ...
    def getRelativeUncertaintyPercent(self) -> float: ...
    def getStandardDeviation(self) -> float: ...
    def getUnit(self) -> java.lang.String: ...
    def getUpper95(self) -> float: ...
    def getUpper99(self) -> float: ...
    def isWithin95CI(self, double: float) -> bool: ...
    def isWithin99CI(self, double: float) -> bool: ...
    def scale(self, double: float) -> "UncertaintyBounds": ...
    def toString(self) -> java.lang.String: ...

class VFMResult(java.io.Serializable):
    @staticmethod
    def builder() -> "VFMResult.Builder": ...
    def getAdditionalProperties(self) -> java.util.Map[java.lang.String, float]: ...
    def getGasFlowRate(self) -> float: ...
    def getGasOilRatio(self) -> float: ...
    def getGasUncertainty(self) -> UncertaintyBounds: ...
    def getOilFlowRate(self) -> float: ...
    def getOilUncertainty(self) -> UncertaintyBounds: ...
    def getProperty(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getQuality(self) -> "VFMResult.Quality": ...
    def getTimestamp(self) -> java.time.Instant: ...
    def getTotalLiquidFlowRate(self) -> float: ...
    def getWaterCut(self) -> float: ...
    def getWaterFlowRate(self) -> float: ...
    def getWaterUncertainty(self) -> UncertaintyBounds: ...
    def isUsable(self) -> bool: ...
    def toString(self) -> java.lang.String: ...

    class Builder:
        def __init__(self): ...
        def addProperty(
            self, string: typing.Union[java.lang.String, str], double: float
        ) -> "VFMResult.Builder": ...
        def build(self) -> "VFMResult": ...
        @typing.overload
        def gasFlowRate(
            self,
            double: float,
            double2: float,
            string: typing.Union[java.lang.String, str],
        ) -> "VFMResult.Builder": ...
        @typing.overload
        def gasFlowRate(
            self, double: float, string: typing.Union[java.lang.String, str]
        ) -> "VFMResult.Builder": ...
        @typing.overload
        def oilFlowRate(
            self,
            double: float,
            double2: float,
            string: typing.Union[java.lang.String, str],
        ) -> "VFMResult.Builder": ...
        @typing.overload
        def oilFlowRate(
            self, double: float, string: typing.Union[java.lang.String, str]
        ) -> "VFMResult.Builder": ...
        def quality(self, quality: "VFMResult.Quality") -> "VFMResult.Builder": ...
        def timestamp(
            self, instant: typing.Union[java.time.Instant, datetime.datetime]
        ) -> "VFMResult.Builder": ...
        @typing.overload
        def waterFlowRate(
            self,
            double: float,
            double2: float,
            string: typing.Union[java.lang.String, str],
        ) -> "VFMResult.Builder": ...
        @typing.overload
        def waterFlowRate(
            self, double: float, string: typing.Union[java.lang.String, str]
        ) -> "VFMResult.Builder": ...

    class Quality(java.lang.Enum["VFMResult.Quality"]):
        HIGH: typing.ClassVar["VFMResult.Quality"] = ...
        NORMAL: typing.ClassVar["VFMResult.Quality"] = ...
        LOW: typing.ClassVar["VFMResult.Quality"] = ...
        EXTRAPOLATED: typing.ClassVar["VFMResult.Quality"] = ...
        INVALID: typing.ClassVar["VFMResult.Quality"] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: typing.Type[_valueOf_0__T],
            string: typing.Union[java.lang.String, str],
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(
            string: typing.Union[java.lang.String, str]
        ) -> "VFMResult.Quality": ...
        @staticmethod
        def values() -> typing.MutableSequence["VFMResult.Quality"]: ...

class VirtualFlowMeter(
    jneqsim.process.measurementdevice.StreamMeasurementDeviceBaseClass
):
    def __init__(
        self,
        string: typing.Union[java.lang.String, str],
        streamInterface: jneqsim.process.equipment.stream.StreamInterface,
    ): ...
    @typing.overload
    def calculateFlowRates(self) -> VFMResult: ...
    @typing.overload
    def calculateFlowRates(
        self, double: float, double2: float, double3: float
    ) -> VFMResult: ...
    def calibrate(
        self, list: java.util.List["VirtualFlowMeter.WellTestData"]
    ) -> None: ...
    def getCalibrationFactor(self) -> float: ...
    def getLastCalibrationTime(self) -> java.time.Instant: ...
    def getLastResult(self) -> VFMResult: ...
    @typing.overload
    def getMeasuredValue(self) -> float: ...
    @typing.overload
    def getMeasuredValue(
        self, string: typing.Union[java.lang.String, str]
    ) -> float: ...
    def getUncertaintyBounds(self) -> UncertaintyBounds: ...
    def setChokeOpening(self, double: float) -> None: ...
    def setDownstreamPressure(self, double: float) -> None: ...
    def setFlowCoefficient(self, double: float) -> None: ...
    def setMeasurementUncertainties(self, double: float, double2: float) -> None: ...
    def setTemperature(self, double: float) -> None: ...
    def setUpstreamPressure(self, double: float) -> None: ...

    class WellTestData:
        def __init__(
            self,
            instant: typing.Union[java.time.Instant, datetime.datetime],
            double: float,
            double2: float,
            double3: float,
            double4: float,
            double5: float,
            double6: float,
        ): ...
        def getChokeOpening(self) -> float: ...
        def getGasRate(self) -> float: ...
        def getOilRate(self) -> float: ...
        def getPressure(self) -> float: ...
        def getTemperature(self) -> float: ...
        def getTimestamp(self) -> java.time.Instant: ...
        def getWaterRate(self) -> float: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.process.measurementdevice.vfm")``.

    SoftSensor: typing.Type[SoftSensor]
    UncertaintyBounds: typing.Type[UncertaintyBounds]
    VFMResult: typing.Type[VFMResult]
    VirtualFlowMeter: typing.Type[VirtualFlowMeter]
