import sys

if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.lang
import java.util
import jneqsim.process.equipment
import jneqsim.process.logic
import typing

class Detector:
    def __init__(
        self,
        string: typing.Union[java.lang.String, str],
        detectorType: "Detector.DetectorType",
        alarmLevel: "Detector.AlarmLevel",
        double: float,
        string2: typing.Union[java.lang.String, str],
    ): ...
    def getAlarmLevel(self) -> "Detector.AlarmLevel": ...
    def getMeasuredValue(self) -> float: ...
    def getName(self) -> java.lang.String: ...
    def getSetpoint(self) -> float: ...
    def getTripTime(self) -> int: ...
    def getType(self) -> "Detector.DetectorType": ...
    def isBypassed(self) -> bool: ...
    def isFaulty(self) -> bool: ...
    def isTripped(self) -> bool: ...
    def reset(self) -> None: ...
    def setBypass(self, boolean: bool) -> None: ...
    def setFaulty(self, boolean: bool) -> None: ...
    def setSetpoint(self, double: float) -> None: ...
    def toString(self) -> java.lang.String: ...
    def trip(self) -> None: ...
    def update(self, double: float) -> None: ...

    class AlarmLevel(java.lang.Enum["Detector.AlarmLevel"]):
        LOW_LOW: typing.ClassVar["Detector.AlarmLevel"] = ...
        LOW: typing.ClassVar["Detector.AlarmLevel"] = ...
        HIGH: typing.ClassVar["Detector.AlarmLevel"] = ...
        HIGH_HIGH: typing.ClassVar["Detector.AlarmLevel"] = ...
        def getNotation(self) -> java.lang.String: ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: typing.Type[_valueOf_0__T],
            string: typing.Union[java.lang.String, str],
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(
            string: typing.Union[java.lang.String, str]
        ) -> "Detector.AlarmLevel": ...
        @staticmethod
        def values() -> typing.MutableSequence["Detector.AlarmLevel"]: ...

    class DetectorType(java.lang.Enum["Detector.DetectorType"]):
        FIRE: typing.ClassVar["Detector.DetectorType"] = ...
        GAS: typing.ClassVar["Detector.DetectorType"] = ...
        PRESSURE: typing.ClassVar["Detector.DetectorType"] = ...
        TEMPERATURE: typing.ClassVar["Detector.DetectorType"] = ...
        LEVEL: typing.ClassVar["Detector.DetectorType"] = ...
        FLOW: typing.ClassVar["Detector.DetectorType"] = ...
        def getDescription(self) -> java.lang.String: ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: typing.Type[_valueOf_0__T],
            string: typing.Union[java.lang.String, str],
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(
            string: typing.Union[java.lang.String, str]
        ) -> "Detector.DetectorType": ...
        @staticmethod
        def values() -> typing.MutableSequence["Detector.DetectorType"]: ...

class SafetyInstrumentedFunction(jneqsim.process.logic.ProcessLogic):
    def __init__(
        self, string: typing.Union[java.lang.String, str], votingLogic: "VotingLogic"
    ): ...
    def activate(self) -> None: ...
    def addDetector(self, detector: Detector) -> None: ...
    def deactivate(self) -> None: ...
    def execute(self, double: float) -> None: ...
    def getDetector(self, int: int) -> Detector: ...
    def getDetectors(self) -> java.util.List[Detector]: ...
    def getName(self) -> java.lang.String: ...
    def getState(self) -> jneqsim.process.logic.LogicState: ...
    def getStatusDescription(self) -> java.lang.String: ...
    def getTargetEquipment(
        self,
    ) -> java.util.List[jneqsim.process.equipment.ProcessEquipmentInterface]: ...
    def getVotingLogic(self) -> "VotingLogic": ...
    def isActive(self) -> bool: ...
    def isComplete(self) -> bool: ...
    def isOverridden(self) -> bool: ...
    def isTripped(self) -> bool: ...
    def linkToLogic(self, processLogic: jneqsim.process.logic.ProcessLogic) -> None: ...
    def reset(self) -> bool: ...
    def setMaxBypassedDetectors(self, int: int) -> None: ...
    def setOverride(self, boolean: bool) -> None: ...
    def toString(self) -> java.lang.String: ...
    def update(self, *double: float) -> None: ...

class VotingLogic(java.lang.Enum["VotingLogic"]):
    ONE_OUT_OF_ONE: typing.ClassVar["VotingLogic"] = ...
    ONE_OUT_OF_TWO: typing.ClassVar["VotingLogic"] = ...
    TWO_OUT_OF_TWO: typing.ClassVar["VotingLogic"] = ...
    TWO_OUT_OF_THREE: typing.ClassVar["VotingLogic"] = ...
    TWO_OUT_OF_FOUR: typing.ClassVar["VotingLogic"] = ...
    THREE_OUT_OF_FOUR: typing.ClassVar["VotingLogic"] = ...
    def evaluate(self, int: int) -> bool: ...
    def getNotation(self) -> java.lang.String: ...
    def getRequiredTrips(self) -> int: ...
    def getTotalSensors(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(
        class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]
    ) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: typing.Union[java.lang.String, str]) -> "VotingLogic": ...
    @staticmethod
    def values() -> typing.MutableSequence["VotingLogic"]: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.process.logic.sis")``.

    Detector: typing.Type[Detector]
    SafetyInstrumentedFunction: typing.Type[SafetyInstrumentedFunction]
    VotingLogic: typing.Type[VotingLogic]
