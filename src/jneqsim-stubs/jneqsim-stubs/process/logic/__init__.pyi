import sys

if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.lang
import java.util
import jneqsim.process.equipment
import jneqsim.process.logic.action
import jneqsim.process.logic.condition
import jneqsim.process.logic.control
import jneqsim.process.logic.esd
import jneqsim.process.logic.hipps
import jneqsim.process.logic.shutdown
import jneqsim.process.logic.sis
import jneqsim.process.logic.startup
import jneqsim.process.logic.voting
import typing

class LogicAction:
    def execute(self) -> None: ...
    def getDescription(self) -> java.lang.String: ...
    def getTargetName(self) -> java.lang.String: ...
    def isComplete(self) -> bool: ...

class LogicCondition:
    def evaluate(self) -> bool: ...
    def getCurrentValue(self) -> java.lang.String: ...
    def getDescription(self) -> java.lang.String: ...
    def getExpectedValue(self) -> java.lang.String: ...
    def getTargetEquipment(
        self,
    ) -> jneqsim.process.equipment.ProcessEquipmentInterface: ...

class LogicState(java.lang.Enum["LogicState"]):
    IDLE: typing.ClassVar["LogicState"] = ...
    RUNNING: typing.ClassVar["LogicState"] = ...
    PAUSED: typing.ClassVar["LogicState"] = ...
    COMPLETED: typing.ClassVar["LogicState"] = ...
    FAILED: typing.ClassVar["LogicState"] = ...
    WAITING_PERMISSIVES: typing.ClassVar["LogicState"] = ...
    _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(
        class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]
    ) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: typing.Union[java.lang.String, str]) -> "LogicState": ...
    @staticmethod
    def values() -> typing.MutableSequence["LogicState"]: ...

class ProcessLogic:
    def activate(self) -> None: ...
    def deactivate(self) -> None: ...
    def execute(self, double: float) -> None: ...
    def getName(self) -> java.lang.String: ...
    def getState(self) -> LogicState: ...
    def getStatusDescription(self) -> java.lang.String: ...
    def getTargetEquipment(
        self,
    ) -> java.util.List[jneqsim.process.equipment.ProcessEquipmentInterface]: ...
    def isActive(self) -> bool: ...
    def isComplete(self) -> bool: ...
    def reset(self) -> bool: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.process.logic")``.

    LogicAction: typing.Type[LogicAction]
    LogicCondition: typing.Type[LogicCondition]
    LogicState: typing.Type[LogicState]
    ProcessLogic: typing.Type[ProcessLogic]
    action: jneqsim.process.logic.action.__module_protocol__
    condition: jneqsim.process.logic.condition.__module_protocol__
    control: jneqsim.process.logic.control.__module_protocol__
    esd: jneqsim.process.logic.esd.__module_protocol__
    hipps: jneqsim.process.logic.hipps.__module_protocol__
    shutdown: jneqsim.process.logic.shutdown.__module_protocol__
    sis: jneqsim.process.logic.sis.__module_protocol__
    startup: jneqsim.process.logic.startup.__module_protocol__
    voting: jneqsim.process.logic.voting.__module_protocol__
