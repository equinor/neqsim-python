
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.time
import java.util
import java.util.function
import jneqsim.process.equipment.reservoir
import jneqsim.process.equipment.stream
import jneqsim.process.processmodel
import jneqsim.process.util.optimization
import typing



class FacilityCapacity(java.io.Serializable):
    DEFAULT_NEAR_BOTTLENECK_THRESHOLD: typing.ClassVar[float] = ...
    DEFAULT_CAPACITY_INCREASE_FACTOR: typing.ClassVar[float] = ...
    def __init__(self, processSystem: jneqsim.process.processmodel.ProcessSystem): ...
    def analyzeOverFieldLife(self, productionForecast: 'ProductionProfile.ProductionForecast', streamInterface: jneqsim.process.equipment.stream.StreamInterface) -> java.util.List['FacilityCapacity.CapacityPeriod']: ...
    def assess(self, streamInterface: jneqsim.process.equipment.stream.StreamInterface, double: float, double2: float, string: typing.Union[java.lang.String, str]) -> 'FacilityCapacity.CapacityAssessment': ...
    def calculateDebottleneckNPV(self, debottleneckOption: 'FacilityCapacity.DebottleneckOption', double: float, double2: float, double3: float, int: int) -> float: ...
    def compareDebottleneckScenarios(self, streamInterface: jneqsim.process.equipment.stream.StreamInterface, list: java.util.List['FacilityCapacity.DebottleneckOption'], double: float, double2: float, string: typing.Union[java.lang.String, str]) -> jneqsim.process.util.optimization.ProductionOptimizer.ScenarioComparisonResult: ...
    def getFacility(self) -> jneqsim.process.processmodel.ProcessSystem: ...
    def getNearBottleneckThreshold(self) -> float: ...
    def setCapacityIncreaseFactor(self, double: float) -> None: ...
    def setCostFactorForName(self, string: typing.Union[java.lang.String, str], double: float) -> None: ...
    def setCostFactorForType(self, class_: typing.Type[typing.Any], double: float) -> None: ...
    def setNearBottleneckThreshold(self, double: float) -> None: ...
    class CapacityAssessment(java.io.Serializable):
        def __init__(self, double: float, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], double2: float, list: java.util.List[jneqsim.process.util.optimization.ProductionOptimizer.UtilizationRecord], list2: java.util.List[typing.Union[java.lang.String, str]], list3: java.util.List['FacilityCapacity.DebottleneckOption'], map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]], boolean: bool): ...
        def getBottleneckUtilization(self) -> float: ...
        def getCurrentBottleneck(self) -> java.lang.String: ...
        def getCurrentMaxRate(self) -> float: ...
        def getDebottleneckOptions(self) -> java.util.List['FacilityCapacity.DebottleneckOption']: ...
        def getEquipmentHeadroom(self) -> java.util.Map[java.lang.String, float]: ...
        def getNearBottlenecks(self) -> java.util.List[java.lang.String]: ...
        def getRateUnit(self) -> java.lang.String: ...
        def getTopOptions(self, int: int) -> java.util.List['FacilityCapacity.DebottleneckOption']: ...
        def getTotalPotentialGain(self) -> float: ...
        def getUtilizationRecords(self) -> java.util.List[jneqsim.process.util.optimization.ProductionOptimizer.UtilizationRecord]: ...
        def isFeasible(self) -> bool: ...
        def toMarkdown(self) -> java.lang.String: ...
    class CapacityPeriod(java.io.Serializable):
        def __init__(self, string: typing.Union[java.lang.String, str], double: float, string2: typing.Union[java.lang.String, str], double2: float, string3: typing.Union[java.lang.String, str], string4: typing.Union[java.lang.String, str], double3: float, map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]], list: java.util.List[typing.Union[java.lang.String, str]], boolean: bool): ...
        def getBottleneckEquipment(self) -> java.lang.String: ...
        def getBottleneckUtilization(self) -> float: ...
        def getEquipmentUtilizations(self) -> java.util.Map[java.lang.String, float]: ...
        def getMaxFacilityRate(self) -> float: ...
        def getNearBottlenecks(self) -> java.util.List[java.lang.String]: ...
        def getPeriodName(self) -> java.lang.String: ...
        def getRateUnit(self) -> java.lang.String: ...
        def getTime(self) -> float: ...
        def getTimeUnit(self) -> java.lang.String: ...
        def isFacilityConstrained(self) -> bool: ...
    class DebottleneckOption(java.io.Serializable, java.lang.Comparable['FacilityCapacity.DebottleneckOption']):
        def __init__(self, string: typing.Union[java.lang.String, str], class_: typing.Type[typing.Any], string2: typing.Union[java.lang.String, str], double: float, double2: float, double3: float, double4: float, string3: typing.Union[java.lang.String, str], double5: float, string4: typing.Union[java.lang.String, str], double6: float, double7: float): ...
        def compareTo(self, debottleneckOption: 'FacilityCapacity.DebottleneckOption') -> int: ...
        def getCapacityIncreasePercent(self) -> float: ...
        def getCapex(self) -> float: ...
        def getCurrency(self) -> java.lang.String: ...
        def getCurrentCapacity(self) -> float: ...
        def getCurrentUtilization(self) -> float: ...
        def getDescription(self) -> java.lang.String: ...
        def getEquipmentName(self) -> java.lang.String: ...
        def getEquipmentType(self) -> typing.Type[typing.Any]: ...
        def getIncrementalProduction(self) -> float: ...
        def getNpv(self) -> float: ...
        def getPaybackYears(self) -> float: ...
        def getRateUnit(self) -> java.lang.String: ...
        def getUpgradedCapacity(self) -> float: ...
        def toString(self) -> java.lang.String: ...

class ProductionProfile(java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, processSystem: jneqsim.process.processmodel.ProcessSystem): ...
    @staticmethod
    def calculateCumulativeProduction(declineParameters: 'ProductionProfile.DeclineParameters', double: float) -> float: ...
    @staticmethod
    def calculateRate(declineParameters: 'ProductionProfile.DeclineParameters', double: float) -> float: ...
    def fitDecline(self, list: java.util.List[float], list2: java.util.List[float], declineType: 'ProductionProfile.DeclineType', string: typing.Union[java.lang.String, str]) -> 'ProductionProfile.DeclineParameters': ...
    def forecast(self, streamInterface: jneqsim.process.equipment.stream.StreamInterface, declineParameters: 'ProductionProfile.DeclineParameters', double: float, double2: float, double3: float, double4: float, double5: float) -> 'ProductionProfile.ProductionForecast': ...
    def getFacility(self) -> jneqsim.process.processmodel.ProcessSystem: ...
    class DeclineParameters(java.io.Serializable):
        @typing.overload
        def __init__(self, double: float, double2: float, double3: float, declineType: 'ProductionProfile.DeclineType', string: typing.Union[java.lang.String, str]): ...
        @typing.overload
        def __init__(self, double: float, double2: float, double3: float, declineType: 'ProductionProfile.DeclineType', string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]): ...
        @typing.overload
        def __init__(self, double: float, double2: float, declineType: 'ProductionProfile.DeclineType', string: typing.Union[java.lang.String, str]): ...
        def getDeclineRate(self) -> float: ...
        def getHyperbolicExponent(self) -> float: ...
        def getInitialRate(self) -> float: ...
        def getRateUnit(self) -> java.lang.String: ...
        def getTimeUnit(self) -> java.lang.String: ...
        def getType(self) -> 'ProductionProfile.DeclineType': ...
        def toString(self) -> java.lang.String: ...
        def withInitialRate(self, double: float) -> 'ProductionProfile.DeclineParameters': ...
    class DeclineType(java.lang.Enum['ProductionProfile.DeclineType']):
        EXPONENTIAL: typing.ClassVar['ProductionProfile.DeclineType'] = ...
        HYPERBOLIC: typing.ClassVar['ProductionProfile.DeclineType'] = ...
        HARMONIC: typing.ClassVar['ProductionProfile.DeclineType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'ProductionProfile.DeclineType': ...
        @staticmethod
        def values() -> typing.MutableSequence['ProductionProfile.DeclineType']: ...
    class ProductionForecast(java.io.Serializable):
        def __init__(self, list: java.util.List['ProductionProfile.ProductionPoint'], double: float, double2: float, double3: float, double4: float, double5: float, double6: float, double7: float, declineParameters: 'ProductionProfile.DeclineParameters'): ...
        def getActualPlateauDuration(self) -> float: ...
        def getActualPlateauRate(self) -> float: ...
        def getDeclineParams(self) -> 'ProductionProfile.DeclineParameters': ...
        def getEconomicLifeYears(self) -> float: ...
        def getEconomicLimit(self) -> float: ...
        def getPlateauDuration(self) -> float: ...
        def getPlateauRate(self) -> float: ...
        def getProfile(self) -> java.util.List['ProductionProfile.ProductionPoint']: ...
        def getTotalRecovery(self) -> float: ...
        def toCSV(self) -> java.lang.String: ...
        def toMarkdownTable(self) -> java.lang.String: ...
    class ProductionPoint(java.io.Serializable):
        def __init__(self, double: float, string: typing.Union[java.lang.String, str], double2: float, double3: float, string2: typing.Union[java.lang.String, str], string3: typing.Union[java.lang.String, str], double4: float, boolean: bool, boolean2: bool): ...
        def getBottleneckEquipment(self) -> java.lang.String: ...
        def getCumulativeProduction(self) -> float: ...
        def getFacilityUtilization(self) -> float: ...
        def getRate(self) -> float: ...
        def getRateUnit(self) -> java.lang.String: ...
        def getTime(self) -> float: ...
        def getTimeUnit(self) -> java.lang.String: ...
        def isAboveEconomicLimit(self) -> bool: ...
        def isOnPlateau(self) -> bool: ...

class SensitivityAnalysis(java.io.Serializable):
    DEFAULT_NUMBER_OF_TRIALS: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, processSystem: jneqsim.process.processmodel.ProcessSystem): ...
    @typing.overload
    def __init__(self, processSystem: jneqsim.process.processmodel.ProcessSystem, random: java.util.Random): ...
    def addParameter(self, uncertainParameter: 'SensitivityAnalysis.UncertainParameter') -> 'SensitivityAnalysis': ...
    def clearParameters(self) -> 'SensitivityAnalysis': ...
    def getBaseProcess(self) -> jneqsim.process.processmodel.ProcessSystem: ...
    def getParameters(self) -> java.util.List['SensitivityAnalysis.UncertainParameter']: ...
    def runMonteCarloOptimization(self, streamInterface: jneqsim.process.equipment.stream.StreamInterface, double: float, double2: float, string: typing.Union[java.lang.String, str], toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[jneqsim.process.util.optimization.ProductionOptimizer.OptimizationResult], typing.Callable[[jneqsim.process.util.optimization.ProductionOptimizer.OptimizationResult], float]], sensitivityConfig: 'SensitivityAnalysis.SensitivityConfig') -> 'SensitivityAnalysis.MonteCarloResult': ...
    def runSpiderAnalysis(self, streamInterface: jneqsim.process.equipment.stream.StreamInterface, double: float, double2: float, string: typing.Union[java.lang.String, str], int: int, toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[jneqsim.process.util.optimization.ProductionOptimizer.OptimizationResult], typing.Callable[[jneqsim.process.util.optimization.ProductionOptimizer.OptimizationResult], float]]) -> java.util.Map[java.lang.String, java.util.List['SensitivityAnalysis.SpiderPoint']]: ...
    def runTornadoAnalysis(self, streamInterface: jneqsim.process.equipment.stream.StreamInterface, double: float, double2: float, string: typing.Union[java.lang.String, str], toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[jneqsim.process.util.optimization.ProductionOptimizer.OptimizationResult], typing.Callable[[jneqsim.process.util.optimization.ProductionOptimizer.OptimizationResult], float]]) -> java.util.Map[java.lang.String, float]: ...
    def setRng(self, random: java.util.Random) -> None: ...
    class DistributionType(java.lang.Enum['SensitivityAnalysis.DistributionType']):
        NORMAL: typing.ClassVar['SensitivityAnalysis.DistributionType'] = ...
        LOGNORMAL: typing.ClassVar['SensitivityAnalysis.DistributionType'] = ...
        TRIANGULAR: typing.ClassVar['SensitivityAnalysis.DistributionType'] = ...
        UNIFORM: typing.ClassVar['SensitivityAnalysis.DistributionType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'SensitivityAnalysis.DistributionType': ...
        @staticmethod
        def values() -> typing.MutableSequence['SensitivityAnalysis.DistributionType']: ...
    class MonteCarloResult(java.io.Serializable):
        def __init__(self, list: java.util.List['SensitivityAnalysis.TrialResult'], map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]], string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]): ...
        def getConvergedCount(self) -> int: ...
        def getFeasibleCount(self) -> int: ...
        def getHistogramData(self, int: int) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
        def getMax(self) -> float: ...
        def getMean(self) -> float: ...
        def getMin(self) -> float: ...
        def getMostSensitiveParameters(self) -> java.util.List[java.lang.String]: ...
        def getOutputName(self) -> java.lang.String: ...
        def getOutputUnit(self) -> java.lang.String: ...
        def getP10(self) -> float: ...
        def getP50(self) -> float: ...
        def getP90(self) -> float: ...
        def getPercentile(self, double: float) -> float: ...
        def getStdDev(self) -> float: ...
        def getTornadoSensitivities(self) -> java.util.Map[java.lang.String, float]: ...
        def getTrials(self) -> java.util.List['SensitivityAnalysis.TrialResult']: ...
        def toCSV(self, list: java.util.List[typing.Union[java.lang.String, str]]) -> java.lang.String: ...
        def toSummaryMarkdown(self) -> java.lang.String: ...
        def toTornadoMarkdown(self) -> java.lang.String: ...
    class SensitivityConfig(java.io.Serializable):
        def __init__(self): ...
        def getNumberOfTrials(self) -> int: ...
        def getParallelThreads(self) -> int: ...
        def getRandomSeed(self) -> int: ...
        def includeBaseCase(self, boolean: bool) -> 'SensitivityAnalysis.SensitivityConfig': ...
        def isIncludeBaseCase(self) -> bool: ...
        def isParallel(self) -> bool: ...
        def isUseFixedSeed(self) -> bool: ...
        def numberOfTrials(self, int: int) -> 'SensitivityAnalysis.SensitivityConfig': ...
        def parallel(self, boolean: bool) -> 'SensitivityAnalysis.SensitivityConfig': ...
        def parallelThreads(self, int: int) -> 'SensitivityAnalysis.SensitivityConfig': ...
        def randomSeed(self, long: int) -> 'SensitivityAnalysis.SensitivityConfig': ...
    class SpiderPoint(java.io.Serializable):
        def __init__(self, double: float, double2: float, double3: float): ...
        def getNormalizedParameter(self) -> float: ...
        def getOutputValue(self) -> float: ...
        def getParameterValue(self) -> float: ...
    class TrialResult(java.io.Serializable, java.lang.Comparable['SensitivityAnalysis.TrialResult']):
        def __init__(self, int: int, map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]], double: float, string: typing.Union[java.lang.String, str], boolean: bool, boolean2: bool): ...
        def compareTo(self, trialResult: 'SensitivityAnalysis.TrialResult') -> int: ...
        def getBottleneck(self) -> java.lang.String: ...
        def getOutputValue(self) -> float: ...
        def getSampledParameters(self) -> java.util.Map[java.lang.String, float]: ...
        def getTrialNumber(self) -> int: ...
        def isConverged(self) -> bool: ...
        def isFeasible(self) -> bool: ...
    class UncertainParameter(java.io.Serializable):
        def __init__(self, string: typing.Union[java.lang.String, str], double: float, double2: float, double3: float, distributionType: 'SensitivityAnalysis.DistributionType', string2: typing.Union[java.lang.String, str], biConsumer: typing.Union[java.util.function.BiConsumer[jneqsim.process.processmodel.ProcessSystem, float], typing.Callable[[jneqsim.process.processmodel.ProcessSystem, float], None]]): ...
        def apply(self, processSystem: jneqsim.process.processmodel.ProcessSystem, double: float) -> None: ...
        def getDistribution(self) -> 'SensitivityAnalysis.DistributionType': ...
        def getName(self) -> java.lang.String: ...
        def getP10(self) -> float: ...
        def getP50(self) -> float: ...
        def getP90(self) -> float: ...
        def getRange(self) -> float: ...
        def getUnit(self) -> java.lang.String: ...
        @staticmethod
        def lognormal(string: typing.Union[java.lang.String, str], double: float, double2: float, double3: float, biConsumer: typing.Union[java.util.function.BiConsumer[jneqsim.process.processmodel.ProcessSystem, float], typing.Callable[[jneqsim.process.processmodel.ProcessSystem, float], None]]) -> 'SensitivityAnalysis.UncertainParameter': ...
        @staticmethod
        def normal(string: typing.Union[java.lang.String, str], double: float, double2: float, double3: float, biConsumer: typing.Union[java.util.function.BiConsumer[jneqsim.process.processmodel.ProcessSystem, float], typing.Callable[[jneqsim.process.processmodel.ProcessSystem, float], None]]) -> 'SensitivityAnalysis.UncertainParameter': ...
        def sample(self, random: java.util.Random) -> float: ...
        def toString(self) -> java.lang.String: ...
        @typing.overload
        @staticmethod
        def triangular(string: typing.Union[java.lang.String, str], double: float, double2: float, double3: float, string2: typing.Union[java.lang.String, str], biConsumer: typing.Union[java.util.function.BiConsumer[jneqsim.process.processmodel.ProcessSystem, float], typing.Callable[[jneqsim.process.processmodel.ProcessSystem, float], None]]) -> 'SensitivityAnalysis.UncertainParameter': ...
        @typing.overload
        @staticmethod
        def triangular(string: typing.Union[java.lang.String, str], double: float, double2: float, double3: float, biConsumer: typing.Union[java.util.function.BiConsumer[jneqsim.process.processmodel.ProcessSystem, float], typing.Callable[[jneqsim.process.processmodel.ProcessSystem, float], None]]) -> 'SensitivityAnalysis.UncertainParameter': ...
        @staticmethod
        def uniform(string: typing.Union[java.lang.String, str], double: float, double2: float, biConsumer: typing.Union[java.util.function.BiConsumer[jneqsim.process.processmodel.ProcessSystem, float], typing.Callable[[jneqsim.process.processmodel.ProcessSystem, float], None]]) -> 'SensitivityAnalysis.UncertainParameter': ...

class WellScheduler(java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, simpleReservoir: jneqsim.process.equipment.reservoir.SimpleReservoir, processSystem: jneqsim.process.processmodel.ProcessSystem): ...
    def addWell(self, string: typing.Union[java.lang.String, str], double: float, string2: typing.Union[java.lang.String, str]) -> 'WellScheduler.WellRecord': ...
    def calculateSystemAvailability(self, localDate: java.time.LocalDate, localDate2: java.time.LocalDate) -> float: ...
    def getAllInterventions(self) -> java.util.List['WellScheduler.Intervention']: ...
    def getAllWells(self) -> java.util.Collection['WellScheduler.WellRecord']: ...
    def getFacility(self) -> jneqsim.process.processmodel.ProcessSystem: ...
    def getReservoir(self) -> jneqsim.process.equipment.reservoir.SimpleReservoir: ...
    def getTotalPotentialOn(self, localDate: java.time.LocalDate) -> float: ...
    def getWell(self, string: typing.Union[java.lang.String, str]) -> 'WellScheduler.WellRecord': ...
    def optimizeSchedule(self, localDate: java.time.LocalDate, localDate2: java.time.LocalDate, int: int) -> 'WellScheduler.ScheduleResult': ...
    def scheduleIntervention(self, intervention: 'WellScheduler.Intervention') -> None: ...
    def setDefaultRateUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...
    class Intervention(java.io.Serializable, java.lang.Comparable['WellScheduler.Intervention']):
        @staticmethod
        def builder(string: typing.Union[java.lang.String, str]) -> 'WellScheduler.Intervention.Builder': ...
        def compareTo(self, intervention: 'WellScheduler.Intervention') -> int: ...
        def getCost(self) -> float: ...
        def getCurrency(self) -> java.lang.String: ...
        def getDescription(self) -> java.lang.String: ...
        def getDurationDays(self) -> int: ...
        def getEndDate(self) -> java.time.LocalDate: ...
        def getExpectedProductionGain(self) -> float: ...
        def getPriority(self) -> int: ...
        def getStartDate(self) -> java.time.LocalDate: ...
        def getType(self) -> 'WellScheduler.InterventionType': ...
        def getWellName(self) -> java.lang.String: ...
        def isActiveOn(self, localDate: java.time.LocalDate) -> bool: ...
        def overlaps(self, localDate: java.time.LocalDate, localDate2: java.time.LocalDate) -> bool: ...
        def toString(self) -> java.lang.String: ...
        class Builder:
            def build(self) -> 'WellScheduler.Intervention': ...
            def cost(self, double: float, string: typing.Union[java.lang.String, str]) -> 'WellScheduler.Intervention.Builder': ...
            def description(self, string: typing.Union[java.lang.String, str]) -> 'WellScheduler.Intervention.Builder': ...
            def durationDays(self, int: int) -> 'WellScheduler.Intervention.Builder': ...
            def expectedGain(self, double: float) -> 'WellScheduler.Intervention.Builder': ...
            def priority(self, int: int) -> 'WellScheduler.Intervention.Builder': ...
            def startDate(self, localDate: java.time.LocalDate) -> 'WellScheduler.Intervention.Builder': ...
            def type(self, interventionType: 'WellScheduler.InterventionType') -> 'WellScheduler.Intervention.Builder': ...
    class InterventionType(java.lang.Enum['WellScheduler.InterventionType']):
        COILED_TUBING: typing.ClassVar['WellScheduler.InterventionType'] = ...
        WIRELINE: typing.ClassVar['WellScheduler.InterventionType'] = ...
        HYDRAULIC_WORKOVER: typing.ClassVar['WellScheduler.InterventionType'] = ...
        RIG_WORKOVER: typing.ClassVar['WellScheduler.InterventionType'] = ...
        STIMULATION: typing.ClassVar['WellScheduler.InterventionType'] = ...
        ARTIFICIAL_LIFT_INSTALL: typing.ClassVar['WellScheduler.InterventionType'] = ...
        WATER_SHUT_OFF: typing.ClassVar['WellScheduler.InterventionType'] = ...
        SCALE_TREATMENT: typing.ClassVar['WellScheduler.InterventionType'] = ...
        PLUG_AND_ABANDON: typing.ClassVar['WellScheduler.InterventionType'] = ...
        def getDisplayName(self) -> java.lang.String: ...
        def getMaxDurationDays(self) -> int: ...
        def getMinDurationDays(self) -> int: ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'WellScheduler.InterventionType': ...
        @staticmethod
        def values() -> typing.MutableSequence['WellScheduler.InterventionType']: ...
    class ScheduleResult(java.io.Serializable):
        def __init__(self, list: java.util.List['WellScheduler.Intervention'], map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]], double: float, double2: float, map2: typing.Union[java.util.Map[java.time.LocalDate, float], typing.Mapping[java.time.LocalDate, float]], map3: typing.Union[java.util.Map[java.time.LocalDate, typing.Union[java.lang.String, str]], typing.Mapping[java.time.LocalDate, typing.Union[java.lang.String, str]]], double3: float, string: typing.Union[java.lang.String, str]): ...
        def getDailyBottleneck(self) -> java.util.Map[java.time.LocalDate, java.lang.String]: ...
        def getDailyFacilityRate(self) -> java.util.Map[java.time.LocalDate, float]: ...
        def getNetProductionImpact(self) -> float: ...
        def getOptimizedSchedule(self) -> java.util.List['WellScheduler.Intervention']: ...
        def getOverallAvailability(self) -> float: ...
        def getTotalDeferredProduction(self) -> float: ...
        def getTotalProductionGain(self) -> float: ...
        def getWellUptime(self) -> java.util.Map[java.lang.String, float]: ...
        def toGanttMarkdown(self) -> java.lang.String: ...
        def toMarkdownTable(self) -> java.lang.String: ...
    class WellRecord(java.io.Serializable):
        def __init__(self, string: typing.Union[java.lang.String, str], double: float, string2: typing.Union[java.lang.String, str]): ...
        def addIntervention(self, intervention: 'WellScheduler.Intervention') -> None: ...
        def calculateAvailability(self, localDate: java.time.LocalDate, localDate2: java.time.LocalDate) -> float: ...
        def getCurrentPotential(self) -> float: ...
        def getCurrentStatus(self) -> 'WellScheduler.WellStatus': ...
        def getInterventionsInRange(self, localDate: java.time.LocalDate, localDate2: java.time.LocalDate) -> java.util.List['WellScheduler.Intervention']: ...
        def getOriginalPotential(self) -> float: ...
        def getRateUnit(self) -> java.lang.String: ...
        def getScheduledInterventions(self) -> java.util.List['WellScheduler.Intervention']: ...
        def getStatusOn(self, localDate: java.time.LocalDate) -> 'WellScheduler.WellStatus': ...
        def getWellName(self) -> java.lang.String: ...
        def recordProduction(self, localDate: java.time.LocalDate, double: float) -> None: ...
        def setCurrentPotential(self, double: float) -> None: ...
        def setStatus(self, wellStatus: 'WellScheduler.WellStatus', localDate: java.time.LocalDate) -> None: ...
    class WellStatus(java.lang.Enum['WellScheduler.WellStatus']):
        PRODUCING: typing.ClassVar['WellScheduler.WellStatus'] = ...
        SHUT_IN: typing.ClassVar['WellScheduler.WellStatus'] = ...
        WORKOVER: typing.ClassVar['WellScheduler.WellStatus'] = ...
        WAITING_ON_WEATHER: typing.ClassVar['WellScheduler.WellStatus'] = ...
        DRILLING: typing.ClassVar['WellScheduler.WellStatus'] = ...
        PLUGGED: typing.ClassVar['WellScheduler.WellStatus'] = ...
        def getDisplayName(self) -> java.lang.String: ...
        def isProducing(self) -> bool: ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'WellScheduler.WellStatus': ...
        @staticmethod
        def values() -> typing.MutableSequence['WellScheduler.WellStatus']: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.process.util.fielddevelopment")``.

    FacilityCapacity: typing.Type[FacilityCapacity]
    ProductionProfile: typing.Type[ProductionProfile]
    SensitivityAnalysis: typing.Type[SensitivityAnalysis]
    WellScheduler: typing.Type[WellScheduler]
