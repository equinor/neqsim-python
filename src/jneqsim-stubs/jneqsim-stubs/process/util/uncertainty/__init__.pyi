
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.util
import jpype
import jneqsim.process.measurementdevice.vfm
import jneqsim.process.processmodel
import typing



class SensitivityMatrix(java.io.Serializable):
    def __init__(self, stringArray: typing.Union[typing.List[java.lang.String], jpype.JArray], stringArray2: typing.Union[typing.List[java.lang.String], jpype.JArray]): ...
    def getInputVariables(self) -> typing.MutableSequence[java.lang.String]: ...
    def getJacobian(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def getMostInfluentialInputs(self) -> java.util.Map[java.lang.String, java.lang.String]: ...
    def getNormalizedSensitivities(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray]) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def getOutputVariables(self) -> typing.MutableSequence[java.lang.String]: ...
    def getSensitivitiesForOutput(self, string: typing.Union[java.lang.String, str]) -> typing.MutableSequence[float]: ...
    def getSensitivity(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> float: ...
    def propagateCovariance(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray]) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def propagateUncertainty(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> typing.MutableSequence[float]: ...
    def setSensitivity(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], double: float) -> None: ...

class UncertaintyAnalyzer:
    def __init__(self, processSystem: jneqsim.process.processmodel.ProcessSystem): ...
    @typing.overload
    def addInputUncertainty(self, string: typing.Union[java.lang.String, str], double: float) -> None: ...
    @typing.overload
    def addInputUncertainty(self, inputUncertainty: 'UncertaintyAnalyzer.InputUncertainty') -> None: ...
    def addOutputVariable(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def analyzeAnalytical(self) -> 'UncertaintyResult': ...
    def analyzeMonteCarlo(self, int: int) -> 'UncertaintyResult': ...
    def setRandomSeed(self, long: int) -> None: ...
    class InputUncertainty:
        @typing.overload
        def __init__(self, string: typing.Union[java.lang.String, str], double: float): ...
        @typing.overload
        def __init__(self, string: typing.Union[java.lang.String, str], double: float, distributionType: 'UncertaintyAnalyzer.InputUncertainty.DistributionType'): ...
        def getDistribution(self) -> 'UncertaintyAnalyzer.InputUncertainty.DistributionType': ...
        def getStandardDeviation(self) -> float: ...
        def getVariableName(self) -> java.lang.String: ...
        class DistributionType(java.lang.Enum['UncertaintyAnalyzer.InputUncertainty.DistributionType']):
            NORMAL: typing.ClassVar['UncertaintyAnalyzer.InputUncertainty.DistributionType'] = ...
            UNIFORM: typing.ClassVar['UncertaintyAnalyzer.InputUncertainty.DistributionType'] = ...
            TRIANGULAR: typing.ClassVar['UncertaintyAnalyzer.InputUncertainty.DistributionType'] = ...
            LOGNORMAL: typing.ClassVar['UncertaintyAnalyzer.InputUncertainty.DistributionType'] = ...
            _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
            @typing.overload
            @staticmethod
            def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
            @typing.overload
            @staticmethod
            def valueOf(string: typing.Union[java.lang.String, str]) -> 'UncertaintyAnalyzer.InputUncertainty.DistributionType': ...
            @staticmethod
            def values() -> typing.MutableSequence['UncertaintyAnalyzer.InputUncertainty.DistributionType']: ...

class UncertaintyResult(java.io.Serializable):
    @typing.overload
    def __init__(self, map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], jneqsim.process.measurementdevice.vfm.UncertaintyBounds], typing.Mapping[typing.Union[java.lang.String, str], jneqsim.process.measurementdevice.vfm.UncertaintyBounds]], int: int, double: float): ...
    @typing.overload
    def __init__(self, map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], jneqsim.process.measurementdevice.vfm.UncertaintyBounds], typing.Mapping[typing.Union[java.lang.String, str], jneqsim.process.measurementdevice.vfm.UncertaintyBounds]], sensitivityMatrix: SensitivityMatrix): ...
    def getAllUncertainties(self) -> java.util.Map[java.lang.String, jneqsim.process.measurementdevice.vfm.UncertaintyBounds]: ...
    def getConvergenceMetric(self) -> float: ...
    def getMonteCarloSamples(self) -> int: ...
    def getMostUncertainOutput(self) -> java.lang.String: ...
    def getOutputsExceedingThreshold(self, double: float) -> java.util.Map[java.lang.String, jneqsim.process.measurementdevice.vfm.UncertaintyBounds]: ...
    def getSensitivityMatrix(self) -> SensitivityMatrix: ...
    def getSummary(self) -> java.lang.String: ...
    def getUncertainty(self, string: typing.Union[java.lang.String, str]) -> jneqsim.process.measurementdevice.vfm.UncertaintyBounds: ...
    def isMonteCarloResult(self) -> bool: ...
    def meetsUncertaintyThreshold(self, double: float) -> bool: ...
    def toString(self) -> java.lang.String: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.process.util.uncertainty")``.

    SensitivityMatrix: typing.Type[SensitivityMatrix]
    UncertaintyAnalyzer: typing.Type[UncertaintyAnalyzer]
    UncertaintyResult: typing.Type[UncertaintyResult]
