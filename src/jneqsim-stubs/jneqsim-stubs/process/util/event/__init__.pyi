
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.time
import java.util
import typing



class ProcessEvent(java.io.Serializable):
    def __init__(self, string: typing.Union[java.lang.String, str], eventType: 'ProcessEvent.EventType', string2: typing.Union[java.lang.String, str], string3: typing.Union[java.lang.String, str], severity: 'ProcessEvent.Severity'): ...
    @staticmethod
    def alarm(string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> 'ProcessEvent': ...
    def getDescription(self) -> java.lang.String: ...
    def getEventId(self) -> java.lang.String: ...
    def getProperties(self) -> java.util.Map[java.lang.String, typing.Any]: ...
    _getProperty_1__T = typing.TypeVar('_getProperty_1__T')  # <T>
    @typing.overload
    def getProperty(self, string: typing.Union[java.lang.String, str]) -> typing.Any: ...
    @typing.overload
    def getProperty(self, string: typing.Union[java.lang.String, str], class_: typing.Type[_getProperty_1__T]) -> _getProperty_1__T: ...
    def getSeverity(self) -> 'ProcessEvent.Severity': ...
    def getSource(self) -> java.lang.String: ...
    def getTimestamp(self) -> java.time.Instant: ...
    def getType(self) -> 'ProcessEvent.EventType': ...
    @staticmethod
    def info(string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> 'ProcessEvent': ...
    @staticmethod
    def modelDeviation(string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], double: float, double2: float) -> 'ProcessEvent': ...
    def setProperty(self, string: typing.Union[java.lang.String, str], object: typing.Any) -> 'ProcessEvent': ...
    @staticmethod
    def thresholdCrossed(string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], double: float, double2: float, boolean: bool) -> 'ProcessEvent': ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def warning(string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> 'ProcessEvent': ...
    class EventType(java.lang.Enum['ProcessEvent.EventType']):
        THRESHOLD_CROSSED: typing.ClassVar['ProcessEvent.EventType'] = ...
        STATE_CHANGE: typing.ClassVar['ProcessEvent.EventType'] = ...
        ALARM: typing.ClassVar['ProcessEvent.EventType'] = ...
        CALIBRATION: typing.ClassVar['ProcessEvent.EventType'] = ...
        SIMULATION_COMPLETE: typing.ClassVar['ProcessEvent.EventType'] = ...
        ERROR: typing.ClassVar['ProcessEvent.EventType'] = ...
        WARNING: typing.ClassVar['ProcessEvent.EventType'] = ...
        INFO: typing.ClassVar['ProcessEvent.EventType'] = ...
        MEASUREMENT_UPDATE: typing.ClassVar['ProcessEvent.EventType'] = ...
        MODEL_DEVIATION: typing.ClassVar['ProcessEvent.EventType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'ProcessEvent.EventType': ...
        @staticmethod
        def values() -> typing.MutableSequence['ProcessEvent.EventType']: ...
    class Severity(java.lang.Enum['ProcessEvent.Severity']):
        DEBUG: typing.ClassVar['ProcessEvent.Severity'] = ...
        INFO: typing.ClassVar['ProcessEvent.Severity'] = ...
        WARNING: typing.ClassVar['ProcessEvent.Severity'] = ...
        ERROR: typing.ClassVar['ProcessEvent.Severity'] = ...
        CRITICAL: typing.ClassVar['ProcessEvent.Severity'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'ProcessEvent.Severity': ...
        @staticmethod
        def values() -> typing.MutableSequence['ProcessEvent.Severity']: ...

class ProcessEventBus(java.io.Serializable):
    def __init__(self): ...
    def clearHistory(self) -> None: ...
    def getEventsBySeverity(self, severity: ProcessEvent.Severity, int: int) -> java.util.List[ProcessEvent]: ...
    def getEventsByType(self, eventType: ProcessEvent.EventType, int: int) -> java.util.List[ProcessEvent]: ...
    def getHistorySize(self) -> int: ...
    @staticmethod
    def getInstance() -> 'ProcessEventBus': ...
    def getRecentEvents(self, int: int) -> java.util.List[ProcessEvent]: ...
    def publish(self, processEvent: ProcessEvent) -> None: ...
    def publishAlarm(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> None: ...
    def publishInfo(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> None: ...
    def publishWarning(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> None: ...
    @staticmethod
    def resetInstance() -> None: ...
    def setAsyncDelivery(self, boolean: bool) -> None: ...
    def setMaxHistorySize(self, int: int) -> None: ...
    def shutdown(self) -> None: ...
    @typing.overload
    def subscribe(self, eventType: ProcessEvent.EventType, processEventListener: typing.Union['ProcessEventListener', typing.Callable]) -> None: ...
    @typing.overload
    def subscribe(self, processEventListener: typing.Union['ProcessEventListener', typing.Callable]) -> None: ...
    @typing.overload
    def unsubscribe(self, eventType: ProcessEvent.EventType, processEventListener: typing.Union['ProcessEventListener', typing.Callable]) -> None: ...
    @typing.overload
    def unsubscribe(self, processEventListener: typing.Union['ProcessEventListener', typing.Callable]) -> None: ...

class ProcessEventListener:
    def onEvent(self, processEvent: ProcessEvent) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.process.util.event")``.

    ProcessEvent: typing.Type[ProcessEvent]
    ProcessEventBus: typing.Type[ProcessEventBus]
    ProcessEventListener: typing.Type[ProcessEventListener]
