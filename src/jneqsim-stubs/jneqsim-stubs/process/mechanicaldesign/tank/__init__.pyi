
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.lang
import jneqsim.process.equipment
import jneqsim.process.mechanicaldesign
import typing



class TankMechanicalDesign(jneqsim.process.mechanicaldesign.MechanicalDesign):
    def __init__(self, processEquipmentInterface: jneqsim.process.equipment.ProcessEquipmentInterface): ...
    def calcDesign(self) -> None: ...
    def displayResults(self) -> None: ...
    def getBottomThickness(self) -> float: ...
    def getBottomWeight(self) -> float: ...
    def getDesignPressure(self) -> float: ...
    def getDesignTemperature(self) -> float: ...
    def getFoundationLoad(self) -> float: ...
    def getNominalCapacity(self) -> float: ...
    def getNumberOfCourses(self) -> int: ...
    def getRoofThickness(self) -> float: ...
    def getRoofType(self) -> 'TankMechanicalDesign.RoofType': ...
    def getRoofWeight(self) -> float: ...
    def getShellThicknesses(self) -> typing.MutableSequence[float]: ...
    def getShellWeight(self) -> float: ...
    def getTankDiameter(self) -> float: ...
    def getTankHeight(self) -> float: ...
    def getTankType(self) -> 'TankMechanicalDesign.TankType': ...
    def getWorkingCapacity(self) -> float: ...
    def hasFloatingRoof(self) -> bool: ...
    def setTankType(self, tankType: 'TankMechanicalDesign.TankType') -> None: ...
    class RoofType(java.lang.Enum['TankMechanicalDesign.RoofType']):
        SELF_SUPPORTING_CONE: typing.ClassVar['TankMechanicalDesign.RoofType'] = ...
        SUPPORTED_CONE: typing.ClassVar['TankMechanicalDesign.RoofType'] = ...
        DOME: typing.ClassVar['TankMechanicalDesign.RoofType'] = ...
        GEODESIC_DOME: typing.ClassVar['TankMechanicalDesign.RoofType'] = ...
        FLOATING: typing.ClassVar['TankMechanicalDesign.RoofType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'TankMechanicalDesign.RoofType': ...
        @staticmethod
        def values() -> typing.MutableSequence['TankMechanicalDesign.RoofType']: ...
    class TankType(java.lang.Enum['TankMechanicalDesign.TankType']):
        FIXED_CONE_ROOF: typing.ClassVar['TankMechanicalDesign.TankType'] = ...
        FIXED_DOME_ROOF: typing.ClassVar['TankMechanicalDesign.TankType'] = ...
        EXTERNAL_FLOATING_ROOF: typing.ClassVar['TankMechanicalDesign.TankType'] = ...
        INTERNAL_FLOATING_ROOF: typing.ClassVar['TankMechanicalDesign.TankType'] = ...
        SPHERICAL: typing.ClassVar['TankMechanicalDesign.TankType'] = ...
        HORIZONTAL_CYLINDRICAL: typing.ClassVar['TankMechanicalDesign.TankType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'TankMechanicalDesign.TankType': ...
        @staticmethod
        def values() -> typing.MutableSequence['TankMechanicalDesign.TankType']: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.process.mechanicaldesign.tank")``.

    TankMechanicalDesign: typing.Type[TankMechanicalDesign]
