
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.util
import jneqsim.process.equipment
import jneqsim.process.equipment.stream
import jneqsim.process.processmodel
import typing



class ProcessEdge(java.io.Serializable):
    @typing.overload
    def __init__(self, int: int, processNode: 'ProcessNode', processNode2: 'ProcessNode', string: typing.Union[java.lang.String, str], edgeType: 'ProcessEdge.EdgeType'): ...
    @typing.overload
    def __init__(self, int: int, processNode: 'ProcessNode', processNode2: 'ProcessNode', streamInterface: jneqsim.process.equipment.stream.StreamInterface): ...
    @typing.overload
    def __init__(self, int: int, processNode: 'ProcessNode', processNode2: 'ProcessNode', streamInterface: jneqsim.process.equipment.stream.StreamInterface, string: typing.Union[java.lang.String, str], edgeType: 'ProcessEdge.EdgeType'): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getEdgeType(self) -> 'ProcessEdge.EdgeType': ...
    def getFeatureVector(self) -> typing.MutableSequence[float]: ...
    def getIndex(self) -> int: ...
    def getIndexPair(self) -> typing.MutableSequence[int]: ...
    def getName(self) -> java.lang.String: ...
    def getSource(self) -> 'ProcessNode': ...
    def getSourceIndex(self) -> int: ...
    def getStream(self) -> jneqsim.process.equipment.stream.StreamInterface: ...
    def getTarget(self) -> 'ProcessNode': ...
    def getTargetIndex(self) -> int: ...
    def hashCode(self) -> int: ...
    def isBackEdge(self) -> bool: ...
    def isRecycle(self) -> bool: ...
    def toString(self) -> java.lang.String: ...
    class EdgeType(java.lang.Enum['ProcessEdge.EdgeType']):
        MATERIAL: typing.ClassVar['ProcessEdge.EdgeType'] = ...
        ENERGY: typing.ClassVar['ProcessEdge.EdgeType'] = ...
        SIGNAL: typing.ClassVar['ProcessEdge.EdgeType'] = ...
        RECYCLE: typing.ClassVar['ProcessEdge.EdgeType'] = ...
        UNKNOWN: typing.ClassVar['ProcessEdge.EdgeType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'ProcessEdge.EdgeType': ...
        @staticmethod
        def values() -> typing.MutableSequence['ProcessEdge.EdgeType']: ...

class ProcessGraph(java.io.Serializable):
    def __init__(self): ...
    @typing.overload
    def addEdge(self, processEquipmentInterface: jneqsim.process.equipment.ProcessEquipmentInterface, processEquipmentInterface2: jneqsim.process.equipment.ProcessEquipmentInterface, streamInterface: jneqsim.process.equipment.stream.StreamInterface) -> ProcessEdge: ...
    @typing.overload
    def addEdge(self, processNode: 'ProcessNode', processNode2: 'ProcessNode', streamInterface: jneqsim.process.equipment.stream.StreamInterface) -> ProcessEdge: ...
    def addNode(self, processEquipmentInterface: jneqsim.process.equipment.ProcessEquipmentInterface) -> 'ProcessNode': ...
    def analyzeCycles(self) -> 'ProcessGraph.CycleAnalysisResult': ...
    def analyzeTearStreamSensitivity(self, list: java.util.List['ProcessNode']) -> 'ProcessGraph.SensitivityAnalysisResult': ...
    def findStronglyConnectedComponents(self) -> 'ProcessGraph.SCCResult': ...
    def getAdjacencyList(self) -> java.util.Map[int, java.util.List[int]]: ...
    def getAdjacencyMatrix(self) -> typing.MutableSequence[typing.MutableSequence[bool]]: ...
    def getCalculationOrder(self) -> java.util.List[jneqsim.process.equipment.ProcessEquipmentInterface]: ...
    def getEdgeCount(self) -> int: ...
    def getEdgeFeatureMatrix(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def getEdgeIndexTensor(self) -> typing.MutableSequence[typing.MutableSequence[int]]: ...
    def getEdges(self) -> java.util.List[ProcessEdge]: ...
    @typing.overload
    def getNode(self, int: int) -> 'ProcessNode': ...
    @typing.overload
    def getNode(self, string: typing.Union[java.lang.String, str]) -> 'ProcessNode': ...
    @typing.overload
    def getNode(self, processEquipmentInterface: jneqsim.process.equipment.ProcessEquipmentInterface) -> 'ProcessNode': ...
    def getNodeCount(self) -> int: ...
    def getNodeFeatureMatrix(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def getNodes(self) -> java.util.List['ProcessNode']: ...
    def getNodesInRecycleLoops(self) -> java.util.Set['ProcessNode']: ...
    def getRecycleEdges(self) -> java.util.List[ProcessEdge]: ...
    def getSensitivityAnalysisReport(self) -> java.lang.String: ...
    def getSinkNodes(self) -> java.util.List['ProcessNode']: ...
    def getSourceNodes(self) -> java.util.List['ProcessNode']: ...
    def getSummary(self) -> java.lang.String: ...
    def getTopologicalOrder(self) -> java.util.List['ProcessNode']: ...
    def hasCycles(self) -> bool: ...
    def partitionForParallelExecution(self) -> 'ProcessGraph.ParallelPartition': ...
    def selectTearStreams(self) -> 'ProcessGraph.TearStreamResult': ...
    def selectTearStreamsForFastConvergence(self) -> 'ProcessGraph.TearStreamResult': ...
    def selectTearStreamsWithSensitivity(self) -> 'ProcessGraph.TearStreamResult': ...
    def toString(self) -> java.lang.String: ...
    def validate(self) -> java.util.List[java.lang.String]: ...
    def validateTearStreams(self, list: java.util.List[ProcessEdge]) -> bool: ...
    class CycleAnalysisResult(java.io.Serializable):
        def getBackEdges(self) -> java.util.List[ProcessEdge]: ...
        def getCycleCount(self) -> int: ...
        def getCycles(self) -> java.util.List[java.util.List['ProcessNode']]: ...
        def hasCycles(self) -> bool: ...
    class ParallelPartition(java.io.Serializable):
        def getLevelCount(self) -> int: ...
        def getLevels(self) -> java.util.List[java.util.List['ProcessNode']]: ...
        def getMaxParallelism(self) -> int: ...
        def getNodeToLevel(self) -> java.util.Map['ProcessNode', int]: ...
    class SCCResult(java.io.Serializable):
        def getComponentCount(self) -> int: ...
        def getComponents(self) -> java.util.List[java.util.List['ProcessNode']]: ...
        def getNodeToComponent(self) -> java.util.Map['ProcessNode', int]: ...
        def getRecycleLoops(self) -> java.util.List[java.util.List['ProcessNode']]: ...
    class SensitivityAnalysisResult(java.io.Serializable):
        def getBestTearStream(self) -> ProcessEdge: ...
        def getEdgeSensitivities(self) -> java.util.Map[ProcessEdge, float]: ...
        def getRankedTearCandidates(self) -> java.util.List[ProcessEdge]: ...
        def getTotalSensitivity(self) -> float: ...
    class TearStreamResult(java.io.Serializable):
        def getSccToTearStreamMap(self) -> java.util.Map[java.util.List['ProcessNode'], ProcessEdge]: ...
        def getTearStreamCount(self) -> int: ...
        def getTearStreams(self) -> java.util.List[ProcessEdge]: ...
        def getTotalCyclesBroken(self) -> int: ...

class ProcessGraphBuilder:
    @staticmethod
    def buildGraph(processSystem: jneqsim.process.processmodel.ProcessSystem) -> ProcessGraph: ...

class ProcessModelGraph(java.io.Serializable):
    def analyzeCycles(self) -> ProcessGraph.CycleAnalysisResult: ...
    def getCalculationOrder(self) -> java.util.List[jneqsim.process.equipment.ProcessEquipmentInterface]: ...
    def getConnectionsFrom(self, string: typing.Union[java.lang.String, str]) -> java.util.List['ProcessModelGraph.InterSystemConnection']: ...
    def getConnectionsTo(self, string: typing.Union[java.lang.String, str]) -> java.util.List['ProcessModelGraph.InterSystemConnection']: ...
    def getEdgeIndexTensor(self) -> typing.MutableSequence[typing.MutableSequence[int]]: ...
    def getFlattenedGraph(self) -> ProcessGraph: ...
    def getIndependentSubSystems(self) -> java.util.List['ProcessModelGraph.SubSystemGraph']: ...
    def getInterSystemConnectionCount(self) -> int: ...
    def getInterSystemConnections(self) -> java.util.List['ProcessModelGraph.InterSystemConnection']: ...
    def getModelName(self) -> java.lang.String: ...
    def getNodeFeatureMatrix(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def getNodeToSubSystemMap(self) -> java.util.Map['ProcessNode', java.lang.String]: ...
    def getStatistics(self) -> java.util.Map[java.lang.String, typing.Any]: ...
    def getSubSystem(self, string: typing.Union[java.lang.String, str]) -> 'ProcessModelGraph.SubSystemGraph': ...
    def getSubSystemByIndex(self, int: int) -> 'ProcessModelGraph.SubSystemGraph': ...
    def getSubSystemCalculationOrder(self) -> java.util.List['ProcessModelGraph.SubSystemGraph']: ...
    def getSubSystemCount(self) -> int: ...
    def getSubSystemDependencies(self) -> java.util.Map[java.lang.String, java.util.Set[java.lang.String]]: ...
    def getSubSystemGraphs(self) -> java.util.List['ProcessModelGraph.SubSystemGraph']: ...
    def getSummary(self) -> java.lang.String: ...
    def getTotalEdgeCount(self) -> int: ...
    def getTotalNodeCount(self) -> int: ...
    def hasCycles(self) -> bool: ...
    def isParallelSubSystemExecutionBeneficial(self) -> bool: ...
    def partitionForParallelExecution(self) -> ProcessGraph.ParallelPartition: ...
    def partitionSubSystemsForParallelExecution(self) -> 'ProcessModelGraph.ModuleParallelPartition': ...
    def toString(self) -> java.lang.String: ...
    class InterSystemConnection(java.io.Serializable):
        def getEdge(self) -> ProcessEdge: ...
        def getSourceNode(self) -> 'ProcessNode': ...
        def getSourceSystemName(self) -> java.lang.String: ...
        def getTargetNode(self) -> 'ProcessNode': ...
        def getTargetSystemName(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class ModuleParallelPartition(java.io.Serializable):
        def getLevelCount(self) -> int: ...
        def getLevelNames(self) -> java.util.List[java.util.List[java.lang.String]]: ...
        def getLevels(self) -> java.util.List[java.util.List['ProcessModelGraph.SubSystemGraph']]: ...
        def getMaxParallelism(self) -> int: ...
        def toString(self) -> java.lang.String: ...
    class SubSystemGraph(java.io.Serializable):
        def getEdgeCount(self) -> int: ...
        def getExecutionIndex(self) -> int: ...
        def getGraph(self) -> ProcessGraph: ...
        def getNodeCount(self) -> int: ...
        def getSystemName(self) -> java.lang.String: ...
        def isModule(self) -> bool: ...

class ProcessModelGraphBuilder:
    @typing.overload
    @staticmethod
    def buildModelGraph(string: typing.Union[java.lang.String, str], *processSystem: jneqsim.process.processmodel.ProcessSystem) -> ProcessModelGraph: ...
    @typing.overload
    @staticmethod
    def buildModelGraph(processModule: jneqsim.process.processmodel.ProcessModule) -> ProcessModelGraph: ...

class ProcessNode(java.io.Serializable):
    def __init__(self, int: int, processEquipmentInterface: jneqsim.process.equipment.ProcessEquipmentInterface): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getEquipment(self) -> jneqsim.process.equipment.ProcessEquipmentInterface: ...
    def getEquipmentType(self) -> java.lang.String: ...
    def getFeatureVector(self, map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], int], typing.Mapping[typing.Union[java.lang.String, str], int]], int: int) -> typing.MutableSequence[float]: ...
    def getInDegree(self) -> int: ...
    def getIncomingEdges(self) -> java.util.List[ProcessEdge]: ...
    def getIndex(self) -> int: ...
    def getName(self) -> java.lang.String: ...
    def getOutDegree(self) -> int: ...
    def getOutgoingEdges(self) -> java.util.List[ProcessEdge]: ...
    def getPredecessors(self) -> java.util.List['ProcessNode']: ...
    def getSuccessors(self) -> java.util.List['ProcessNode']: ...
    def hashCode(self) -> int: ...
    def isSink(self) -> bool: ...
    def isSource(self) -> bool: ...
    def toString(self) -> java.lang.String: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.process.processmodel.graph")``.

    ProcessEdge: typing.Type[ProcessEdge]
    ProcessGraph: typing.Type[ProcessGraph]
    ProcessGraphBuilder: typing.Type[ProcessGraphBuilder]
    ProcessModelGraph: typing.Type[ProcessModelGraph]
    ProcessModelGraphBuilder: typing.Type[ProcessModelGraphBuilder]
    ProcessNode: typing.Type[ProcessNode]
