import sys

if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.time
import java.util
import typing

class PredictionResult(java.io.Serializable):
    @typing.overload
    def __init__(self, duration: java.time.Duration): ...
    @typing.overload
    def __init__(
        self, duration: java.time.Duration, string: typing.Union[java.lang.String, str]
    ): ...
    def addAssumption(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def addPredictedValue(
        self,
        string: typing.Union[java.lang.String, str],
        predictedValue: "PredictionResult.PredictedValue",
    ) -> None: ...
    def addViolation(
        self, constraintViolation: "PredictionResult.ConstraintViolation"
    ) -> None: ...
    def getAdvisoryRecommendation(self) -> java.lang.String: ...
    def getAllPredictedValues(
        self,
    ) -> java.util.Map[java.lang.String, "PredictionResult.PredictedValue"]: ...
    def getAssumptions(self) -> java.util.List[java.lang.String]: ...
    def getExplanation(self) -> java.lang.String: ...
    def getHorizon(self) -> java.time.Duration: ...
    def getOverallConfidence(self) -> float: ...
    def getPredictionTime(self) -> java.time.Instant: ...
    def getScenarioName(self) -> java.lang.String: ...
    def getStatus(self) -> "PredictionResult.PredictionStatus": ...
    def getValue(
        self, string: typing.Union[java.lang.String, str]
    ) -> "PredictionResult.PredictedValue": ...
    def getViolationSummary(self) -> java.lang.String: ...
    def getViolations(
        self,
    ) -> java.util.List["PredictionResult.ConstraintViolation"]: ...
    def hasViolations(self) -> bool: ...
    def setExplanation(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def setOverallConfidence(self, double: float) -> None: ...
    def setStatus(
        self, predictionStatus: "PredictionResult.PredictionStatus"
    ) -> None: ...

    class ConstraintViolation(java.io.Serializable):
        def __init__(
            self,
            string: typing.Union[java.lang.String, str],
            string2: typing.Union[java.lang.String, str],
            double: float,
            double2: float,
            string3: typing.Union[java.lang.String, str],
            duration: java.time.Duration,
            severity: "PredictionResult.ConstraintViolation.Severity",
        ): ...
        def getConstraintName(self) -> java.lang.String: ...
        def getDescription(self) -> java.lang.String: ...
        def getLimitValue(self) -> float: ...
        def getPredictedValue(self) -> float: ...
        def getSeverity(self) -> "PredictionResult.ConstraintViolation.Severity": ...
        def getSuggestedAction(self) -> java.lang.String: ...
        def getTimeToViolation(self) -> java.time.Duration: ...
        def getUnit(self) -> java.lang.String: ...
        def getVariableName(self) -> java.lang.String: ...
        def setSuggestedAction(
            self, string: typing.Union[java.lang.String, str]
        ) -> None: ...

        class Severity(java.lang.Enum["PredictionResult.ConstraintViolation.Severity"]):
            LOW: typing.ClassVar["PredictionResult.ConstraintViolation.Severity"] = ...
            MEDIUM: typing.ClassVar["PredictionResult.ConstraintViolation.Severity"] = (
                ...
            )
            HIGH: typing.ClassVar["PredictionResult.ConstraintViolation.Severity"] = ...
            CRITICAL: typing.ClassVar[
                "PredictionResult.ConstraintViolation.Severity"
            ] = ...
            _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
            @typing.overload
            @staticmethod
            def valueOf(
                class_: typing.Type[_valueOf_0__T],
                string: typing.Union[java.lang.String, str],
            ) -> _valueOf_0__T: ...
            @typing.overload
            @staticmethod
            def valueOf(
                string: typing.Union[java.lang.String, str]
            ) -> "PredictionResult.ConstraintViolation.Severity": ...
            @staticmethod
            def values() -> (
                typing.MutableSequence["PredictionResult.ConstraintViolation.Severity"]
            ): ...

    class PredictedValue(java.io.Serializable):
        @typing.overload
        def __init__(
            self,
            double: float,
            double2: float,
            double3: float,
            string: typing.Union[java.lang.String, str],
            double4: float,
        ): ...
        @typing.overload
        def __init__(
            self,
            double: float,
            double2: float,
            string: typing.Union[java.lang.String, str],
        ): ...
        @staticmethod
        def deterministic(
            double: float, string: typing.Union[java.lang.String, str]
        ) -> "PredictionResult.PredictedValue": ...
        def getConfidence(self) -> float: ...
        def getLower95(self) -> float: ...
        def getMean(self) -> float: ...
        def getStandardDeviation(self) -> float: ...
        def getUnit(self) -> java.lang.String: ...
        def getUpper95(self) -> float: ...
        def toString(self) -> java.lang.String: ...

    class PredictionStatus(java.lang.Enum["PredictionResult.PredictionStatus"]):
        SUCCESS: typing.ClassVar["PredictionResult.PredictionStatus"] = ...
        WARNING: typing.ClassVar["PredictionResult.PredictionStatus"] = ...
        FAILED: typing.ClassVar["PredictionResult.PredictionStatus"] = ...
        DATA_QUALITY_ISSUE: typing.ClassVar["PredictionResult.PredictionStatus"] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: typing.Type[_valueOf_0__T],
            string: typing.Union[java.lang.String, str],
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(
            string: typing.Union[java.lang.String, str]
        ) -> "PredictionResult.PredictionStatus": ...
        @staticmethod
        def values() -> typing.MutableSequence["PredictionResult.PredictionStatus"]: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.process.advisory")``.

    PredictionResult: typing.Type[PredictionResult]
