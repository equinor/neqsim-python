import sys

if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import Jama
import java.io
import java.lang
import jneqsim.fluidmechanics.flownode
import jneqsim.fluidmechanics.flownode.fluidboundary.heatmasstransfercalc.equilibriumfluidboundary
import jneqsim.fluidmechanics.flownode.fluidboundary.heatmasstransfercalc.finitevolumeboundary
import jneqsim.fluidmechanics.flownode.fluidboundary.heatmasstransfercalc.nonequilibriumfluidboundary
import jneqsim.fluidmechanics.flownode.fluidboundary.heatmasstransfercalc.nonequilibriumfluidboundary.filmmodelboundary.reactivefilmmodel.enhancementfactor
import jneqsim.thermo.system
import jneqsim.thermodynamicoperations
import typing

class FluidBoundaryInterface(java.lang.Cloneable):
    def calcFluxes(self) -> typing.MutableSequence[float]: ...
    def clone(self) -> "FluidBoundaryInterface": ...
    def display(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def getBinaryMassTransferCoefficient(
        self, int: int, int2: int, int3: int
    ) -> float: ...
    def getBulkSystem(self) -> jneqsim.thermo.system.SystemInterface: ...
    def getBulkSystemOpertions(
        self,
    ) -> jneqsim.thermodynamicoperations.ThermodynamicOperations: ...
    def getEffectiveMassTransferCoefficient(self, int: int, int2: int) -> float: ...
    def getEnhancementFactor(
        self,
    ) -> (
        jneqsim.fluidmechanics.flownode.fluidboundary.heatmasstransfercalc.nonequilibriumfluidboundary.filmmodelboundary.reactivefilmmodel.enhancementfactor.EnhancementFactor
    ): ...
    def getInterphaseHeatFlux(self, int: int) -> float: ...
    def getInterphaseMolarFlux(self, int: int) -> float: ...
    def getInterphaseSystem(self) -> jneqsim.thermo.system.SystemInterface: ...
    def getMassTransferCoefficientMatrix(
        self,
    ) -> typing.MutableSequence[Jama.Matrix]: ...
    def heatTransSolve(self) -> None: ...
    def isHeatTransferCalc(self) -> bool: ...
    def massTransSolve(self) -> None: ...
    def setEnhancementType(self, int: int) -> None: ...
    def setHeatTransferCalc(self, boolean: bool) -> None: ...
    def setInterphaseSystem(
        self, systemInterface: jneqsim.thermo.system.SystemInterface
    ) -> None: ...
    def setMassTransferCalc(self, boolean: bool) -> None: ...
    def solve(self) -> None: ...
    @typing.overload
    def useFiniteFluxCorrection(self, int: int) -> bool: ...
    @typing.overload
    def useFiniteFluxCorrection(self, boolean: bool) -> None: ...
    @typing.overload
    def useFiniteFluxCorrection(self, boolean: bool, int: int) -> None: ...
    @typing.overload
    def useThermodynamicCorrections(self, int: int) -> bool: ...
    @typing.overload
    def useThermodynamicCorrections(self, boolean: bool) -> None: ...
    @typing.overload
    def useThermodynamicCorrections(self, boolean: bool, int: int) -> None: ...
    def write(
        self,
        string: typing.Union[java.lang.String, str],
        string2: typing.Union[java.lang.String, str],
        boolean: bool,
    ) -> None: ...

class InterfacialAreaModel(java.lang.Enum["InterfacialAreaModel"]):
    GEOMETRIC: typing.ClassVar["InterfacialAreaModel"] = ...
    EMPIRICAL_CORRELATION: typing.ClassVar["InterfacialAreaModel"] = ...
    USER_DEFINED: typing.ClassVar["InterfacialAreaModel"] = ...
    def getDescription(self) -> java.lang.String: ...
    def getDisplayName(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(
        class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]
    ) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(
        string: typing.Union[java.lang.String, str]
    ) -> "InterfacialAreaModel": ...
    @staticmethod
    def values() -> typing.MutableSequence["InterfacialAreaModel"]: ...

class MassTransferModel(java.lang.Enum["MassTransferModel"]):
    KRISHNA_STANDART_FILM: typing.ClassVar["MassTransferModel"] = ...
    PENETRATION_THEORY: typing.ClassVar["MassTransferModel"] = ...
    SURFACE_RENEWAL: typing.ClassVar["MassTransferModel"] = ...
    def getDescription(self) -> java.lang.String: ...
    def getDisplayName(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(
        class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]
    ) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: typing.Union[java.lang.String, str]) -> "MassTransferModel": ...
    @staticmethod
    def values() -> typing.MutableSequence["MassTransferModel"]: ...

class WallHeatTransferModel(java.lang.Enum["WallHeatTransferModel"]):
    CONSTANT_WALL_TEMPERATURE: typing.ClassVar["WallHeatTransferModel"] = ...
    CONSTANT_HEAT_FLUX: typing.ClassVar["WallHeatTransferModel"] = ...
    CONVECTIVE_BOUNDARY: typing.ClassVar["WallHeatTransferModel"] = ...
    ADIABATIC: typing.ClassVar["WallHeatTransferModel"] = ...
    def getDescription(self) -> java.lang.String: ...
    def getDisplayName(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(
        class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]
    ) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(
        string: typing.Union[java.lang.String, str]
    ) -> "WallHeatTransferModel": ...
    @staticmethod
    def values() -> typing.MutableSequence["WallHeatTransferModel"]: ...

class FluidBoundary(FluidBoundaryInterface, java.io.Serializable):
    interphaseHeatFlux: typing.MutableSequence[float] = ...
    massTransferCalc: bool = ...
    heatTransferCalc: bool = ...
    thermodynamicCorrections: typing.MutableSequence[bool] = ...
    finiteFluxCorrection: typing.MutableSequence[bool] = ...
    binaryMassTransferCoefficient: typing.MutableSequence[
        typing.MutableSequence[typing.MutableSequence[float]]
    ] = ...
    heatTransferCoefficient: typing.MutableSequence[float] = ...
    heatTransferCorrection: typing.MutableSequence[float] = ...
    @typing.overload
    def __init__(
        self, flowNodeInterface: jneqsim.fluidmechanics.flownode.FlowNodeInterface
    ): ...
    @typing.overload
    def __init__(self, systemInterface: jneqsim.thermo.system.SystemInterface): ...
    def calcFluxTypeCorrectionMatrix(self, int: int, int2: int) -> None: ...
    def calcNonIdealCorrections(self, int: int) -> None: ...
    def clone(self) -> "FluidBoundary": ...
    def createTable(
        self, string: typing.Union[java.lang.String, str]
    ) -> typing.MutableSequence[typing.MutableSequence[java.lang.String]]: ...
    def display(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def getBinaryMassTransferCoefficient(
        self, int: int, int2: int, int3: int
    ) -> float: ...
    def getBulkSystem(self) -> jneqsim.thermo.system.SystemInterface: ...
    def getBulkSystemOpertions(
        self,
    ) -> jneqsim.thermodynamicoperations.ThermodynamicOperations: ...
    def getEffectiveMassTransferCoefficient(self, int: int, int2: int) -> float: ...
    def getEnhancementFactor(
        self,
    ) -> (
        jneqsim.fluidmechanics.flownode.fluidboundary.heatmasstransfercalc.nonequilibriumfluidboundary.filmmodelboundary.reactivefilmmodel.enhancementfactor.EnhancementFactor
    ): ...
    def getInterphaseHeatFlux(self, int: int) -> float: ...
    def getInterphaseMolarFlux(self, int: int) -> float: ...
    def getInterphaseOpertions(
        self,
    ) -> jneqsim.thermodynamicoperations.ThermodynamicOperations: ...
    def getInterphaseSystem(self) -> jneqsim.thermo.system.SystemInterface: ...
    def getMassTransferCoefficientMatrix(
        self,
    ) -> typing.MutableSequence[Jama.Matrix]: ...
    def heatTransSolve(self) -> None: ...
    def init(self) -> None: ...
    def initHeatTransferCalc(self) -> None: ...
    def initInterphaseSystem(self) -> None: ...
    def initMassTransferCalc(self) -> None: ...
    def isHeatTransferCalc(self) -> bool: ...
    def massTransSolve(self) -> None: ...
    def setBulkSystem(
        self, systemInterface: jneqsim.thermo.system.SystemInterface
    ) -> None: ...
    def setEnhancementType(self, int: int) -> None: ...
    def setHeatTransferCalc(self, boolean: bool) -> None: ...
    def setInterphaseSystem(
        self, systemInterface: jneqsim.thermo.system.SystemInterface
    ) -> None: ...
    def setMassTransferCalc(self, boolean: bool) -> None: ...
    def setSolverType(self, int: int) -> None: ...
    @typing.overload
    def useFiniteFluxCorrection(self, int: int) -> bool: ...
    @typing.overload
    def useFiniteFluxCorrection(self, boolean: bool) -> None: ...
    @typing.overload
    def useFiniteFluxCorrection(self, boolean: bool, int: int) -> None: ...
    @typing.overload
    def useThermodynamicCorrections(self, int: int) -> bool: ...
    @typing.overload
    def useThermodynamicCorrections(self, boolean: bool) -> None: ...
    @typing.overload
    def useThermodynamicCorrections(self, boolean: bool, int: int) -> None: ...
    def write(
        self,
        string: typing.Union[java.lang.String, str],
        string2: typing.Union[java.lang.String, str],
        boolean: bool,
    ) -> None: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.fluidmechanics.flownode.fluidboundary.heatmasstransfercalc")``.

    FluidBoundary: typing.Type[FluidBoundary]
    FluidBoundaryInterface: typing.Type[FluidBoundaryInterface]
    InterfacialAreaModel: typing.Type[InterfacialAreaModel]
    MassTransferModel: typing.Type[MassTransferModel]
    WallHeatTransferModel: typing.Type[WallHeatTransferModel]
    equilibriumfluidboundary: (
        jneqsim.fluidmechanics.flownode.fluidboundary.heatmasstransfercalc.equilibriumfluidboundary.__module_protocol__
    )
    finitevolumeboundary: (
        jneqsim.fluidmechanics.flownode.fluidboundary.heatmasstransfercalc.finitevolumeboundary.__module_protocol__
    )
    nonequilibriumfluidboundary: (
        jneqsim.fluidmechanics.flownode.fluidboundary.heatmasstransfercalc.nonequilibriumfluidboundary.__module_protocol__
    )
