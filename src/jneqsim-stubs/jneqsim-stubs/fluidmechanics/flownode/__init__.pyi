import sys

if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.lang
import jpype
import jneqsim.fluidmechanics.flownode.fluidboundary
import jneqsim.fluidmechanics.flownode.fluidboundary.heatmasstransfercalc
import jneqsim.fluidmechanics.flownode.fluidboundary.interphasetransportcoefficient
import jneqsim.fluidmechanics.flownode.multiphasenode
import jneqsim.fluidmechanics.flownode.onephasenode
import jneqsim.fluidmechanics.flownode.twophasenode
import jneqsim.fluidmechanics.geometrydefinitions
import jneqsim.thermo
import jneqsim.thermo.system
import jneqsim.thermodynamicoperations
import jneqsim.util.util
import typing

class FlowNodeInterface(java.lang.Cloneable):
    def calcFluxes(self) -> None: ...
    def calcNusseltNumber(self, double: float, int: int) -> float: ...
    def calcSherwoodNumber(self, double: float, int: int) -> float: ...
    def calcStantonNumber(self, double: float, int: int) -> float: ...
    def calcTotalHeatTransferCoefficient(self, int: int) -> float: ...
    @typing.overload
    def display(self, string: typing.Union[java.lang.String, str]) -> None: ...
    @typing.overload
    def display(self) -> None: ...
    def getArea(self, int: int) -> float: ...
    def getBulkSystem(self) -> jneqsim.thermo.system.SystemInterface: ...
    def getDistanceToCenterOfNode(self) -> float: ...
    def getEffectiveSchmidtNumber(self, int: int, int2: int) -> float: ...
    def getFlowDirection(self, int: int) -> int: ...
    def getFlowNodeType(self) -> java.lang.String: ...
    def getFluidBoundary(
        self,
    ) -> (
        jneqsim.fluidmechanics.flownode.fluidboundary.heatmasstransfercalc.FluidBoundaryInterface
    ): ...
    def getGeometry(
        self,
    ) -> jneqsim.fluidmechanics.geometrydefinitions.GeometryDefinitionInterface: ...
    def getHydraulicDiameter(self, int: int) -> float: ...
    def getInterPhaseFrictionFactor(self) -> float: ...
    def getInterphaseContactArea(self) -> float: ...
    def getInterphaseContactLength(self, int: int) -> float: ...
    def getInterphaseSystem(self) -> jneqsim.thermo.system.SystemInterface: ...
    def getInterphaseTransportCoefficient(
        self,
    ) -> (
        jneqsim.fluidmechanics.flownode.fluidboundary.interphasetransportcoefficient.InterphaseTransportCoefficientInterface
    ): ...
    def getLengthOfNode(self) -> float: ...
    def getMassFlowRate(self, int: int) -> float: ...
    def getMolarMassTransferRate(self, int: int) -> float: ...
    def getNextNode(self) -> "FlowNodeInterface": ...
    def getOperations(
        self,
    ) -> jneqsim.thermodynamicoperations.ThermodynamicOperations: ...
    def getPhaseFraction(self, int: int) -> float: ...
    def getPrandtlNumber(self, int: int) -> float: ...
    @typing.overload
    def getReynoldsNumber(self, int: int) -> float: ...
    @typing.overload
    def getReynoldsNumber(self) -> float: ...
    def getSchmidtNumber(self, int: int, int2: int, int3: int) -> float: ...
    def getSuperficialVelocity(self, int: int) -> float: ...
    @typing.overload
    def getVelocity(self, int: int) -> float: ...
    @typing.overload
    def getVelocity(self) -> float: ...
    @typing.overload
    def getVelocityIn(self, int: int) -> jneqsim.util.util.DoubleCloneable: ...
    @typing.overload
    def getVelocityIn(self) -> jneqsim.util.util.DoubleCloneable: ...
    @typing.overload
    def getVelocityOut(self, int: int) -> jneqsim.util.util.DoubleCloneable: ...
    @typing.overload
    def getVelocityOut(self) -> jneqsim.util.util.DoubleCloneable: ...
    def getVerticalPositionOfNode(self) -> float: ...
    def getVolumetricFlow(self) -> float: ...
    def getWallContactLength(self, int: int) -> float: ...
    @typing.overload
    def getWallFrictionFactor(self, int: int) -> float: ...
    @typing.overload
    def getWallFrictionFactor(self) -> float: ...
    def increaseMolarRate(self, double: float) -> None: ...
    def init(self) -> None: ...
    def initBulkSystem(self) -> None: ...
    def initFlowCalc(self) -> None: ...
    def setBulkSystem(
        self, systemInterface: jneqsim.thermo.system.SystemInterface
    ) -> None: ...
    def setDistanceToCenterOfNode(self, double: float) -> None: ...
    def setEnhancementType(self, int: int) -> None: ...
    def setFlowDirection(self, int: int, int2: int) -> None: ...
    def setFluxes(
        self, doubleArray: typing.Union[typing.List[float], jpype.JArray]
    ) -> None: ...
    def setFrictionFactorType(self, int: int) -> None: ...
    def setGeometryDefinitionInterface(
        self,
        geometryDefinitionInterface: jneqsim.fluidmechanics.geometrydefinitions.GeometryDefinitionInterface,
    ) -> None: ...
    def setInterphaseModelType(self, int: int) -> None: ...
    def setInterphaseSystem(
        self, systemInterface: jneqsim.thermo.system.SystemInterface
    ) -> None: ...
    def setLengthOfNode(self, double: float) -> None: ...
    def setPhaseFraction(self, int: int, double: float) -> None: ...
    @typing.overload
    def setVelocity(self, int: int, double: float) -> None: ...
    @typing.overload
    def setVelocity(self, double: float) -> None: ...
    @typing.overload
    def setVelocityIn(self, int: int, double: float) -> None: ...
    @typing.overload
    def setVelocityIn(
        self, int: int, doubleCloneable: jneqsim.util.util.DoubleCloneable
    ) -> None: ...
    @typing.overload
    def setVelocityIn(self, double: float) -> None: ...
    @typing.overload
    def setVelocityIn(
        self, doubleCloneable: jneqsim.util.util.DoubleCloneable
    ) -> None: ...
    @typing.overload
    def setVelocityOut(self, int: int, double: float) -> None: ...
    @typing.overload
    def setVelocityOut(
        self, int: int, doubleCloneable: jneqsim.util.util.DoubleCloneable
    ) -> None: ...
    @typing.overload
    def setVelocityOut(self, double: float) -> None: ...
    @typing.overload
    def setVelocityOut(
        self, doubleCloneable: jneqsim.util.util.DoubleCloneable
    ) -> None: ...
    def setVerticalPositionOfNode(self, double: float) -> None: ...
    @typing.overload
    def setWallFrictionFactor(self, int: int, double: float) -> None: ...
    @typing.overload
    def setWallFrictionFactor(self, double: float) -> None: ...
    def update(self) -> None: ...
    def updateMolarFlow(self) -> None: ...
    def write(
        self,
        string: typing.Union[java.lang.String, str],
        string2: typing.Union[java.lang.String, str],
        boolean: bool,
    ) -> None: ...

class FlowNodeSelector:
    def __init__(self): ...
    def getFlowNodeType(
        self,
        flowNodeInterfaceArray: typing.Union[
            typing.List[FlowNodeInterface], jpype.JArray
        ],
    ) -> None: ...
    def setFlowPattern(
        self,
        flowNodeInterfaceArray: typing.Union[
            typing.List[FlowNodeInterface], jpype.JArray
        ],
        string: typing.Union[java.lang.String, str],
    ) -> None: ...

class FlowPattern(java.lang.Enum["FlowPattern"]):
    STRATIFIED: typing.ClassVar["FlowPattern"] = ...
    STRATIFIED_WAVY: typing.ClassVar["FlowPattern"] = ...
    ANNULAR: typing.ClassVar["FlowPattern"] = ...
    SLUG: typing.ClassVar["FlowPattern"] = ...
    BUBBLE: typing.ClassVar["FlowPattern"] = ...
    DROPLET: typing.ClassVar["FlowPattern"] = ...
    CHURN: typing.ClassVar["FlowPattern"] = ...
    DISPERSED_BUBBLE: typing.ClassVar["FlowPattern"] = ...
    @staticmethod
    def fromString(string: typing.Union[java.lang.String, str]) -> "FlowPattern": ...
    def getName(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(
        class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]
    ) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: typing.Union[java.lang.String, str]) -> "FlowPattern": ...
    @staticmethod
    def values() -> typing.MutableSequence["FlowPattern"]: ...

class FlowPatternDetector:
    @staticmethod
    def calculateLiquidHoldup(
        flowPattern: FlowPattern, double: float, double2: float, double3: float
    ) -> float: ...
    @staticmethod
    def detectFlowPattern(
        flowPatternModel: "FlowPatternModel",
        double: float,
        double2: float,
        double3: float,
        double4: float,
        double5: float,
        double6: float,
        double7: float,
        double8: float,
        double9: float,
    ) -> FlowPattern: ...

class FlowPatternModel(java.lang.Enum["FlowPatternModel"]):
    MANUAL: typing.ClassVar["FlowPatternModel"] = ...
    BAKER_CHART: typing.ClassVar["FlowPatternModel"] = ...
    TAITEL_DUKLER: typing.ClassVar["FlowPatternModel"] = ...
    BARNEA: typing.ClassVar["FlowPatternModel"] = ...
    BEGGS_BRILL: typing.ClassVar["FlowPatternModel"] = ...
    _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(
        class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]
    ) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: typing.Union[java.lang.String, str]) -> "FlowPatternModel": ...
    @staticmethod
    def values() -> typing.MutableSequence["FlowPatternModel"]: ...

class HeatTransferCoefficientCalculator:
    @staticmethod
    def calculateCondensationHTC(
        double: float,
        double2: float,
        double3: float,
        double4: float,
        double5: float,
        double6: float,
        double7: float,
        double8: float,
    ) -> float: ...
    @staticmethod
    def calculateCondensationNusselt(
        double: float,
        double2: float,
        double3: float,
        double4: float,
        double5: float,
        double6: float,
        double7: float,
    ) -> float: ...
    @staticmethod
    def calculateDittusBoelterNusselt(
        double: float, double2: float, boolean: bool
    ) -> float: ...
    @staticmethod
    def calculateEvaporationHTC(
        double: float,
        double2: float,
        double3: float,
        double4: float,
        double5: float,
        double6: float,
        double7: float,
        double8: float,
    ) -> float: ...
    @staticmethod
    def calculateGasHeatTransferCoefficient(
        flowPattern: FlowPattern,
        double: float,
        double2: float,
        double3: float,
        double4: float,
        double5: float,
        double6: float,
        double7: float,
    ) -> float: ...
    @staticmethod
    def calculateGnielinskiNusselt(
        double: float, double2: float, double3: float
    ) -> float: ...
    @staticmethod
    def calculateLaminarNusselt(boolean: bool) -> float: ...
    @staticmethod
    def calculateLiquidHeatTransferCoefficient(
        flowPattern: FlowPattern,
        double: float,
        double2: float,
        double3: float,
        double4: float,
        double5: float,
        double6: float,
        double7: float,
        double8: float,
    ) -> float: ...
    @staticmethod
    def calculateOverallInterphaseCoefficient(
        double: float, double2: float
    ) -> float: ...
    @staticmethod
    def calculateStantonNumber(
        double: float, double2: float, double3: float, double4: float
    ) -> float: ...

class InterfacialAreaCalculator:
    @staticmethod
    def calculateAnnularArea(double: float, double2: float) -> float: ...
    @staticmethod
    def calculateBubbleArea(
        double: float, double2: float, double3: float, double4: float, double5: float
    ) -> float: ...
    @staticmethod
    def calculateChurnArea(double: float, double2: float) -> float: ...
    @staticmethod
    def calculateDropletArea(
        double: float, double2: float, double3: float, double4: float, double5: float
    ) -> float: ...
    @staticmethod
    def calculateInterfacialArea(
        flowPattern: FlowPattern,
        double: float,
        double2: float,
        double3: float,
        double4: float,
        double5: float,
        double6: float,
        double7: float,
    ) -> float: ...
    @staticmethod
    def calculateSauterDiameter(
        double: float, double2: float, double3: float, double4: float
    ) -> float: ...
    @staticmethod
    def calculateSlugArea(
        double: float,
        double2: float,
        double3: float,
        double4: float,
        double5: float,
        double6: float,
        double7: float,
    ) -> float: ...
    @staticmethod
    def calculateStratifiedArea(double: float, double2: float) -> float: ...

class InterfacialAreaModel(java.lang.Enum["InterfacialAreaModel"]):
    GEOMETRIC: typing.ClassVar["InterfacialAreaModel"] = ...
    EMPIRICAL_CORRELATION: typing.ClassVar["InterfacialAreaModel"] = ...
    USER_DEFINED: typing.ClassVar["InterfacialAreaModel"] = ...
    def getName(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(
        class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]
    ) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(
        string: typing.Union[java.lang.String, str]
    ) -> "InterfacialAreaModel": ...
    @staticmethod
    def values() -> typing.MutableSequence["InterfacialAreaModel"]: ...

class MassTransferCoefficientCalculator:
    @staticmethod
    def calculateDittusBoelterSherwood(double: float, double2: float) -> float: ...
    @staticmethod
    def calculateGasMassTransferCoefficient(
        flowPattern: FlowPattern,
        double: float,
        double2: float,
        double3: float,
        double4: float,
        double5: float,
        double6: float,
    ) -> float: ...
    @staticmethod
    def calculateLiquidMassTransferCoefficient(
        flowPattern: FlowPattern,
        double: float,
        double2: float,
        double3: float,
        double4: float,
        double5: float,
        double6: float,
        double7: float,
    ) -> float: ...
    @staticmethod
    def calculateRanzMarshallSherwood(double: float, double2: float) -> float: ...

class WallHeatTransferModel(java.lang.Enum["WallHeatTransferModel"]):
    ADIABATIC: typing.ClassVar["WallHeatTransferModel"] = ...
    CONSTANT_WALL_TEMPERATURE: typing.ClassVar["WallHeatTransferModel"] = ...
    CONSTANT_HEAT_FLUX: typing.ClassVar["WallHeatTransferModel"] = ...
    CONVECTIVE_BOUNDARY: typing.ClassVar["WallHeatTransferModel"] = ...
    TRANSIENT_WALL_TEMPERATURE: typing.ClassVar["WallHeatTransferModel"] = ...
    _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(
        class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]
    ) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(
        string: typing.Union[java.lang.String, str]
    ) -> "WallHeatTransferModel": ...
    @staticmethod
    def values() -> typing.MutableSequence["WallHeatTransferModel"]: ...

class FlowNode(FlowNodeInterface, jneqsim.thermo.ThermodynamicConstantsInterface):
    molarFlowRate: typing.MutableSequence[float] = ...
    massFlowRate: typing.MutableSequence[float] = ...
    volumetricFlowRate: typing.MutableSequence[float] = ...
    bulkSystem: jneqsim.thermo.system.SystemInterface = ...
    velocityIn: typing.MutableSequence[jneqsim.util.util.DoubleCloneable] = ...
    velocityOut: typing.MutableSequence[jneqsim.util.util.DoubleCloneable] = ...
    superficialVelocity: typing.MutableSequence[float] = ...
    interphaseContactArea: float = ...
    velocity: typing.MutableSequence[float] = ...
    pipe: jneqsim.fluidmechanics.geometrydefinitions.GeometryDefinitionInterface = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, systemInterface: jneqsim.thermo.system.SystemInterface): ...
    @typing.overload
    def __init__(
        self,
        systemInterface: jneqsim.thermo.system.SystemInterface,
        geometryDefinitionInterface: jneqsim.fluidmechanics.geometrydefinitions.GeometryDefinitionInterface,
    ): ...
    @typing.overload
    def __init__(
        self,
        systemInterface: jneqsim.thermo.system.SystemInterface,
        geometryDefinitionInterface: jneqsim.fluidmechanics.geometrydefinitions.GeometryDefinitionInterface,
        double: float,
        double2: float,
    ): ...
    def calcFluxes(self) -> None: ...
    def calcNusseltNumber(self, double: float, int: int) -> float: ...
    def calcSherwoodNumber(self, double: float, int: int) -> float: ...
    def calcStantonNumber(self, double: float, int: int) -> float: ...
    def calcTotalHeatTransferCoefficient(self, int: int) -> float: ...
    def clone(self) -> "FlowNode": ...
    def createTable(
        self, string: typing.Union[java.lang.String, str]
    ) -> typing.MutableSequence[typing.MutableSequence[java.lang.String]]: ...
    @typing.overload
    def display(self) -> None: ...
    @typing.overload
    def display(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def getArea(self, int: int) -> float: ...
    def getBulkSystem(self) -> jneqsim.thermo.system.SystemInterface: ...
    def getDistanceToCenterOfNode(self) -> float: ...
    def getEffectiveSchmidtNumber(self, int: int, int2: int) -> float: ...
    def getFlowDirection(self, int: int) -> int: ...
    def getFlowNodeType(self) -> java.lang.String: ...
    def getFluidBoundary(
        self,
    ) -> (
        jneqsim.fluidmechanics.flownode.fluidboundary.heatmasstransfercalc.FluidBoundaryInterface
    ): ...
    def getGeometry(
        self,
    ) -> jneqsim.fluidmechanics.geometrydefinitions.GeometryDefinitionInterface: ...
    def getHydraulicDiameter(self, int: int) -> float: ...
    def getInterPhaseFrictionFactor(self) -> float: ...
    def getInterphaseContactArea(self) -> float: ...
    def getInterphaseContactLength(self, int: int) -> float: ...
    def getInterphaseSystem(self) -> jneqsim.thermo.system.SystemInterface: ...
    def getInterphaseTransportCoefficient(
        self,
    ) -> (
        jneqsim.fluidmechanics.flownode.fluidboundary.interphasetransportcoefficient.InterphaseTransportCoefficientInterface
    ): ...
    def getLengthOfNode(self) -> float: ...
    def getMassFlowRate(self, int: int) -> float: ...
    def getMolarMassTransferRate(self, int: int) -> float: ...
    def getNextNode(self) -> FlowNodeInterface: ...
    def getOperations(
        self,
    ) -> jneqsim.thermodynamicoperations.ThermodynamicOperations: ...
    def getPhaseFraction(self, int: int) -> float: ...
    def getPrandtlNumber(self, int: int) -> float: ...
    @typing.overload
    def getReynoldsNumber(self) -> float: ...
    @typing.overload
    def getReynoldsNumber(self, int: int) -> float: ...
    def getSchmidtNumber(self, int: int, int2: int, int3: int) -> float: ...
    def getSuperficialVelocity(self, int: int) -> float: ...
    @typing.overload
    def getVelocity(self) -> float: ...
    @typing.overload
    def getVelocity(self, int: int) -> float: ...
    @typing.overload
    def getVelocityIn(self) -> jneqsim.util.util.DoubleCloneable: ...
    @typing.overload
    def getVelocityIn(self, int: int) -> jneqsim.util.util.DoubleCloneable: ...
    @typing.overload
    def getVelocityOut(self) -> jneqsim.util.util.DoubleCloneable: ...
    @typing.overload
    def getVelocityOut(self, int: int) -> jneqsim.util.util.DoubleCloneable: ...
    def getVerticalPositionOfNode(self) -> float: ...
    def getVolumetricFlow(self) -> float: ...
    def getWallContactLength(self, int: int) -> float: ...
    @typing.overload
    def getWallFrictionFactor(self) -> float: ...
    @typing.overload
    def getWallFrictionFactor(self, int: int) -> float: ...
    def increaseMolarRate(self, double: float) -> None: ...
    def init(self) -> None: ...
    def initBulkSystem(self) -> None: ...
    def setBulkSystem(
        self, systemInterface: jneqsim.thermo.system.SystemInterface
    ) -> None: ...
    def setDistanceToCenterOfNode(self, double: float) -> None: ...
    def setEnhancementType(self, int: int) -> None: ...
    def setFlowDirection(self, int: int, int2: int) -> None: ...
    def setFluxes(
        self, doubleArray: typing.Union[typing.List[float], jpype.JArray]
    ) -> None: ...
    def setFrictionFactorType(self, int: int) -> None: ...
    def setGeometryDefinitionInterface(
        self,
        geometryDefinitionInterface: jneqsim.fluidmechanics.geometrydefinitions.GeometryDefinitionInterface,
    ) -> None: ...
    def setInterphaseModelType(self, int: int) -> None: ...
    def setInterphaseSystem(
        self, systemInterface: jneqsim.thermo.system.SystemInterface
    ) -> None: ...
    def setLengthOfNode(self, double: float) -> None: ...
    def setOperations(
        self,
        thermodynamicOperations: jneqsim.thermodynamicoperations.ThermodynamicOperations,
    ) -> None: ...
    def setPhaseFraction(self, int: int, double: float) -> None: ...
    @typing.overload
    def setVelocity(self, double: float) -> None: ...
    @typing.overload
    def setVelocity(self, int: int, double: float) -> None: ...
    @typing.overload
    def setVelocityIn(self, double: float) -> None: ...
    @typing.overload
    def setVelocityIn(
        self, doubleCloneable: jneqsim.util.util.DoubleCloneable
    ) -> None: ...
    @typing.overload
    def setVelocityIn(self, int: int, double: float) -> None: ...
    @typing.overload
    def setVelocityIn(
        self, int: int, doubleCloneable: jneqsim.util.util.DoubleCloneable
    ) -> None: ...
    @typing.overload
    def setVelocityOut(self, double: float) -> None: ...
    @typing.overload
    def setVelocityOut(
        self, doubleCloneable: jneqsim.util.util.DoubleCloneable
    ) -> None: ...
    @typing.overload
    def setVelocityOut(self, int: int, double: float) -> None: ...
    @typing.overload
    def setVelocityOut(
        self, int: int, doubleCloneable: jneqsim.util.util.DoubleCloneable
    ) -> None: ...
    def setVerticalPositionOfNode(self, double: float) -> None: ...
    @typing.overload
    def setWallFrictionFactor(self, double: float) -> None: ...
    @typing.overload
    def setWallFrictionFactor(self, int: int, double: float) -> None: ...
    def update(self) -> None: ...
    def updateMolarFlow(self) -> None: ...
    def write(
        self,
        string: typing.Union[java.lang.String, str],
        string2: typing.Union[java.lang.String, str],
        boolean: bool,
    ) -> None: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.fluidmechanics.flownode")``.

    FlowNode: typing.Type[FlowNode]
    FlowNodeInterface: typing.Type[FlowNodeInterface]
    FlowNodeSelector: typing.Type[FlowNodeSelector]
    FlowPattern: typing.Type[FlowPattern]
    FlowPatternDetector: typing.Type[FlowPatternDetector]
    FlowPatternModel: typing.Type[FlowPatternModel]
    HeatTransferCoefficientCalculator: typing.Type[HeatTransferCoefficientCalculator]
    InterfacialAreaCalculator: typing.Type[InterfacialAreaCalculator]
    InterfacialAreaModel: typing.Type[InterfacialAreaModel]
    MassTransferCoefficientCalculator: typing.Type[MassTransferCoefficientCalculator]
    WallHeatTransferModel: typing.Type[WallHeatTransferModel]
    fluidboundary: jneqsim.fluidmechanics.flownode.fluidboundary.__module_protocol__
    multiphasenode: jneqsim.fluidmechanics.flownode.multiphasenode.__module_protocol__
    onephasenode: jneqsim.fluidmechanics.flownode.onephasenode.__module_protocol__
    twophasenode: jneqsim.fluidmechanics.flownode.twophasenode.__module_protocol__
