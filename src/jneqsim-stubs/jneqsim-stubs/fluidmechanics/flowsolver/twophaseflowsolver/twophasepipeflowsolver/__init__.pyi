import sys

if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.lang
import jneqsim.fluidmechanics.flowsolver.onephaseflowsolver
import jneqsim.fluidmechanics.flowsystem
import jneqsim.thermo
import typing

class TwoPhasePipeFlowSolver(
    jneqsim.fluidmechanics.flowsolver.onephaseflowsolver.OnePhaseFlowSolver
):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(
        self,
        flowSystemInterface: jneqsim.fluidmechanics.flowsystem.FlowSystemInterface,
        double: float,
        int: int,
    ): ...
    def clone(self) -> "TwoPhasePipeFlowSolver": ...

class TwoPhaseFixedStaggeredGridSolver(
    TwoPhasePipeFlowSolver, jneqsim.thermo.ThermodynamicConstantsInterface
):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(
        self,
        flowSystemInterface: jneqsim.fluidmechanics.flowsystem.FlowSystemInterface,
        double: float,
        int: int,
    ): ...
    @typing.overload
    def __init__(
        self,
        flowSystemInterface: jneqsim.fluidmechanics.flowsystem.FlowSystemInterface,
        double: float,
        int: int,
        boolean: bool,
    ): ...
    def calcFluxes(self) -> None: ...
    def checkPhaseTransitions(self) -> int: ...
    def clone(self) -> "TwoPhaseFixedStaggeredGridSolver": ...
    def getMassTransferMode(
        self,
    ) -> "TwoPhaseFixedStaggeredGridSolver.MassTransferMode": ...
    def getSolverTypeEnum(self) -> "TwoPhaseFixedStaggeredGridSolver.SolverType": ...
    def initComposition(self, int: int, int2: int) -> None: ...
    def initFinalResults(self, int: int) -> None: ...
    def initMatrix(self) -> None: ...
    def initNodes(self) -> None: ...
    def initPhaseFraction(self, int: int) -> None: ...
    def initPressure(self, int: int) -> None: ...
    def initProfiles(self) -> None: ...
    def initTemperature(self, int: int) -> None: ...
    def initVelocity(self, int: int) -> None: ...
    def setComponentConservationMatrix(self, int: int, int2: int) -> None: ...
    def setComponentConservationMatrix2(self, int: int, int2: int) -> None: ...
    def setEnergyMatrixTDMA(self, int: int) -> None: ...
    def setImpulsMatrixTDMA(self, int: int) -> None: ...
    def setMassConservationMatrix(self, int: int) -> None: ...
    def setMassTransferMode(
        self, massTransferMode: "TwoPhaseFixedStaggeredGridSolver.MassTransferMode"
    ) -> None: ...
    def setPhaseFractionMatrix(self, int: int) -> None: ...
    @typing.overload
    def setSolverType(self, int: int) -> None: ...
    @typing.overload
    def setSolverType(
        self, solverType: "TwoPhaseFixedStaggeredGridSolver.SolverType"
    ) -> None: ...
    def solveTDMA(self) -> None: ...

    class MassTransferMode(
        java.lang.Enum["TwoPhaseFixedStaggeredGridSolver.MassTransferMode"]
    ):
        BIDIRECTIONAL: typing.ClassVar[
            "TwoPhaseFixedStaggeredGridSolver.MassTransferMode"
        ] = ...
        DISSOLUTION_ONLY: typing.ClassVar[
            "TwoPhaseFixedStaggeredGridSolver.MassTransferMode"
        ] = ...
        EVAPORATION_ONLY: typing.ClassVar[
            "TwoPhaseFixedStaggeredGridSolver.MassTransferMode"
        ] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: typing.Type[_valueOf_0__T],
            string: typing.Union[java.lang.String, str],
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(
            string: typing.Union[java.lang.String, str]
        ) -> "TwoPhaseFixedStaggeredGridSolver.MassTransferMode": ...
        @staticmethod
        def values() -> (
            typing.MutableSequence["TwoPhaseFixedStaggeredGridSolver.MassTransferMode"]
        ): ...

    class SolverType(java.lang.Enum["TwoPhaseFixedStaggeredGridSolver.SolverType"]):
        SIMPLE: typing.ClassVar["TwoPhaseFixedStaggeredGridSolver.SolverType"] = ...
        FULL: typing.ClassVar["TwoPhaseFixedStaggeredGridSolver.SolverType"] = ...
        DEFAULT: typing.ClassVar["TwoPhaseFixedStaggeredGridSolver.SolverType"] = ...
        def getLegacyType(self) -> int: ...
        def solveComposition(self) -> bool: ...
        def solveEnergy(self) -> bool: ...
        def solveMomentum(self) -> bool: ...
        def solvePhaseFraction(self) -> bool: ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: typing.Type[_valueOf_0__T],
            string: typing.Union[java.lang.String, str],
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(
            string: typing.Union[java.lang.String, str]
        ) -> "TwoPhaseFixedStaggeredGridSolver.SolverType": ...
        @staticmethod
        def values() -> (
            typing.MutableSequence["TwoPhaseFixedStaggeredGridSolver.SolverType"]
        ): ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.fluidmechanics.flowsolver.twophaseflowsolver.twophasepipeflowsolver")``.

    TwoPhaseFixedStaggeredGridSolver: typing.Type[TwoPhaseFixedStaggeredGridSolver]
    TwoPhasePipeFlowSolver: typing.Type[TwoPhasePipeFlowSolver]
