
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import jneqsim.fluidmechanics.flowsolver.onephaseflowsolver
import jneqsim.fluidmechanics.flowsolver.twophaseflowsolver
import typing



class AdvectionScheme(java.lang.Enum['AdvectionScheme']):
    FIRST_ORDER_UPWIND: typing.ClassVar['AdvectionScheme'] = ...
    SECOND_ORDER_UPWIND: typing.ClassVar['AdvectionScheme'] = ...
    QUICK: typing.ClassVar['AdvectionScheme'] = ...
    TVD_VAN_LEER: typing.ClassVar['AdvectionScheme'] = ...
    TVD_MINMOD: typing.ClassVar['AdvectionScheme'] = ...
    TVD_SUPERBEE: typing.ClassVar['AdvectionScheme'] = ...
    TVD_VAN_ALBADA: typing.ClassVar['AdvectionScheme'] = ...
    MUSCL_VAN_LEER: typing.ClassVar['AdvectionScheme'] = ...
    def getDispersionReductionFactor(self) -> float: ...
    def getDisplayName(self) -> java.lang.String: ...
    def getMaxCFL(self) -> float: ...
    def getOrder(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def usesTVD(self) -> bool: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: typing.Union[java.lang.String, str]) -> 'AdvectionScheme': ...
    @staticmethod
    def values() -> typing.MutableSequence['AdvectionScheme']: ...

class FlowSolverInterface:
    def setBoundarySpecificationType(self, int: int) -> None: ...
    def setDynamic(self, boolean: bool) -> None: ...
    def setSolverType(self, int: int) -> None: ...
    def setTimeStep(self, double: float) -> None: ...
    def solve(self) -> None: ...
    def solveTDMA(self) -> None: ...

class FluxLimiter:
    @staticmethod
    def getLimiterValue(advectionScheme: AdvectionScheme, double: float) -> float: ...
    @staticmethod
    def gradientRatio(double: float, double2: float, double3: float) -> float: ...
    @staticmethod
    def mc(double: float) -> float: ...
    @staticmethod
    def minmod(double: float) -> float: ...
    @staticmethod
    def minmod2(double: float, double2: float) -> float: ...
    @staticmethod
    def minmod3(double: float, double2: float, double3: float) -> float: ...
    @staticmethod
    def sign(double: float) -> float: ...
    @staticmethod
    def superbee(double: float) -> float: ...
    @staticmethod
    def vanAlbada(double: float) -> float: ...
    @staticmethod
    def vanLeer(double: float) -> float: ...

class FlowSolver(FlowSolverInterface, java.io.Serializable):
    def __init__(self): ...
    def setBoundarySpecificationType(self, int: int) -> None: ...
    def setDynamic(self, boolean: bool) -> None: ...
    def setSolverType(self, int: int) -> None: ...
    def setTimeStep(self, double: float) -> None: ...
    def solve(self) -> None: ...
    def solveTDMA(self) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.fluidmechanics.flowsolver")``.

    AdvectionScheme: typing.Type[AdvectionScheme]
    FlowSolver: typing.Type[FlowSolver]
    FlowSolverInterface: typing.Type[FlowSolverInterface]
    FluxLimiter: typing.Type[FluxLimiter]
    onephaseflowsolver: jneqsim.fluidmechanics.flowsolver.onephaseflowsolver.__module_protocol__
    twophaseflowsolver: jneqsim.fluidmechanics.flowsolver.twophaseflowsolver.__module_protocol__
