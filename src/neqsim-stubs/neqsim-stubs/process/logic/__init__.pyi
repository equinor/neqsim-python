
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.lang
import java.util
import neqsim.process.equipment
import neqsim.process.logic.action
import neqsim.process.logic.condition
import neqsim.process.logic.control
import neqsim.process.logic.esd
import neqsim.process.logic.hipps
import neqsim.process.logic.shutdown
import neqsim.process.logic.sis
import neqsim.process.logic.startup
import neqsim.process.logic.voting
import typing



class LogicAction:
    def execute(self) -> None: ...
    def getDescription(self) -> java.lang.String: ...
    def getTargetName(self) -> java.lang.String: ...
    def isComplete(self) -> bool: ...

class LogicCondition:
    def evaluate(self) -> bool: ...
    def getCurrentValue(self) -> java.lang.String: ...
    def getDescription(self) -> java.lang.String: ...
    def getExpectedValue(self) -> java.lang.String: ...
    def getTargetEquipment(self) -> neqsim.process.equipment.ProcessEquipmentInterface: ...

class LogicState(java.lang.Enum['LogicState']):
    IDLE: typing.ClassVar['LogicState'] = ...
    RUNNING: typing.ClassVar['LogicState'] = ...
    PAUSED: typing.ClassVar['LogicState'] = ...
    COMPLETED: typing.ClassVar['LogicState'] = ...
    FAILED: typing.ClassVar['LogicState'] = ...
    WAITING_PERMISSIVES: typing.ClassVar['LogicState'] = ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: typing.Union[java.lang.String, str]) -> 'LogicState': ...
    @staticmethod
    def values() -> typing.MutableSequence['LogicState']: ...

class ProcessLogic:
    def activate(self) -> None: ...
    def deactivate(self) -> None: ...
    def execute(self, double: float) -> None: ...
    def getName(self) -> java.lang.String: ...
    def getState(self) -> LogicState: ...
    def getStatusDescription(self) -> java.lang.String: ...
    def getTargetEquipment(self) -> java.util.List[neqsim.process.equipment.ProcessEquipmentInterface]: ...
    def isActive(self) -> bool: ...
    def isComplete(self) -> bool: ...
    def reset(self) -> bool: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("neqsim.process.logic")``.

    LogicAction: typing.Type[LogicAction]
    LogicCondition: typing.Type[LogicCondition]
    LogicState: typing.Type[LogicState]
    ProcessLogic: typing.Type[ProcessLogic]
    action: neqsim.process.logic.action.__module_protocol__
    condition: neqsim.process.logic.condition.__module_protocol__
    control: neqsim.process.logic.control.__module_protocol__
    esd: neqsim.process.logic.esd.__module_protocol__
    hipps: neqsim.process.logic.hipps.__module_protocol__
    shutdown: neqsim.process.logic.shutdown.__module_protocol__
    sis: neqsim.process.logic.sis.__module_protocol__
    startup: neqsim.process.logic.startup.__module_protocol__
    voting: neqsim.process.logic.voting.__module_protocol__
