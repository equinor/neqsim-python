
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.util
import neqsim.process.controllerdevice.structure
import neqsim.process.measurementdevice
import neqsim.util
import typing



class ControllerDeviceInterface(java.io.Serializable):
    def addGainSchedulePoint(self, double: float, double2: float, double3: float, double4: float) -> None: ...
    @typing.overload
    def autoTune(self, double: float, double2: float) -> None: ...
    @typing.overload
    def autoTune(self, double: float, double2: float, boolean: bool) -> None: ...
    @typing.overload
    def autoTuneFromEventLog(self) -> bool: ...
    @typing.overload
    def autoTuneFromEventLog(self, boolean: bool) -> bool: ...
    @typing.overload
    def autoTuneStepResponse(self, double: float, double2: float, double3: float) -> None: ...
    @typing.overload
    def autoTuneStepResponse(self, double: float, double2: float, double3: float, boolean: bool) -> None: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getControllerSetPoint(self) -> float: ...
    def getEventLog(self) -> java.util.List['ControllerEvent']: ...
    def getIntegralAbsoluteError(self) -> float: ...
    @typing.overload
    def getMeasuredValue(self) -> float: ...
    @typing.overload
    def getMeasuredValue(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getResponse(self) -> float: ...
    def getSettlingTime(self) -> float: ...
    def getStepResponseTuningMethod(self) -> 'ControllerDeviceInterface.StepResponseTuningMethod': ...
    def getUnit(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    def isActive(self) -> bool: ...
    def isReverseActing(self) -> bool: ...
    def resetEventLog(self) -> None: ...
    def resetPerformanceMetrics(self) -> None: ...
    @typing.overload
    def runTransient(self, double: float, double2: float, uUID: java.util.UUID) -> None: ...
    @typing.overload
    def runTransient(self, double: float, double2: float) -> None: ...
    def setActive(self, boolean: bool) -> None: ...
    def setControllerParameters(self, double: float, double2: float, double3: float) -> None: ...
    @typing.overload
    def setControllerSetPoint(self, double: float) -> None: ...
    @typing.overload
    def setControllerSetPoint(self, double: float, string: typing.Union[java.lang.String, str]) -> None: ...
    def setDerivativeFilterTime(self, double: float) -> None: ...
    def setOutputLimits(self, double: float, double2: float) -> None: ...
    def setReverseActing(self, boolean: bool) -> None: ...
    def setStepResponseTuningMethod(self, stepResponseTuningMethod: 'ControllerDeviceInterface.StepResponseTuningMethod') -> None: ...
    def setTransmitter(self, measurementDeviceInterface: neqsim.process.measurementdevice.MeasurementDeviceInterface) -> None: ...
    def setUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...
    class StepResponseTuningMethod(java.lang.Enum['ControllerDeviceInterface.StepResponseTuningMethod']):
        CLASSIC: typing.ClassVar['ControllerDeviceInterface.StepResponseTuningMethod'] = ...
        SIMC: typing.ClassVar['ControllerDeviceInterface.StepResponseTuningMethod'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'ControllerDeviceInterface.StepResponseTuningMethod': ...
        @staticmethod
        def values() -> typing.MutableSequence['ControllerDeviceInterface.StepResponseTuningMethod']: ...

class ControllerEvent(java.io.Serializable):
    def __init__(self, double: float, double2: float, double3: float, double4: float, double5: float): ...
    def getError(self) -> float: ...
    def getMeasuredValue(self) -> float: ...
    def getResponse(self) -> float: ...
    def getSetPoint(self) -> float: ...
    def getTime(self) -> float: ...

class ControllerDeviceBaseClass(neqsim.util.NamedBaseClass, ControllerDeviceInterface):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: typing.Union[java.lang.String, str]): ...
    def addGainSchedulePoint(self, double: float, double2: float, double3: float, double4: float) -> None: ...
    @typing.overload
    def autoTune(self, double: float, double2: float) -> None: ...
    @typing.overload
    def autoTune(self, double: float, double2: float, boolean: bool) -> None: ...
    @typing.overload
    def autoTuneFromEventLog(self) -> bool: ...
    @typing.overload
    def autoTuneFromEventLog(self, boolean: bool) -> bool: ...
    @typing.overload
    def autoTuneStepResponse(self, double: float, double2: float, double3: float) -> None: ...
    @typing.overload
    def autoTuneStepResponse(self, double: float, double2: float, double3: float, boolean: bool) -> None: ...
    def getControllerSetPoint(self) -> float: ...
    def getEventLog(self) -> java.util.List[ControllerEvent]: ...
    def getIntegralAbsoluteError(self) -> float: ...
    def getKp(self) -> float: ...
    @typing.overload
    def getMeasuredValue(self) -> float: ...
    @typing.overload
    def getMeasuredValue(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getResponse(self) -> float: ...
    def getSettlingTime(self) -> float: ...
    def getStepResponseTuningMethod(self) -> ControllerDeviceInterface.StepResponseTuningMethod: ...
    def getTd(self) -> float: ...
    def getTi(self) -> float: ...
    def getUnit(self) -> java.lang.String: ...
    def isActive(self) -> bool: ...
    def isReverseActing(self) -> bool: ...
    def resetEventLog(self) -> None: ...
    def resetPerformanceMetrics(self) -> None: ...
    @typing.overload
    def runTransient(self, double: float, double2: float) -> None: ...
    @typing.overload
    def runTransient(self, double: float, double2: float, uUID: java.util.UUID) -> None: ...
    def setActive(self, boolean: bool) -> None: ...
    def setControllerParameters(self, double: float, double2: float, double3: float) -> None: ...
    @typing.overload
    def setControllerSetPoint(self, double: float) -> None: ...
    @typing.overload
    def setControllerSetPoint(self, double: float, string: typing.Union[java.lang.String, str]) -> None: ...
    def setDerivativeFilterTime(self, double: float) -> None: ...
    def setKp(self, double: float) -> None: ...
    def setOutputLimits(self, double: float, double2: float) -> None: ...
    def setReverseActing(self, boolean: bool) -> None: ...
    def setStepResponseTuningMethod(self, stepResponseTuningMethod: ControllerDeviceInterface.StepResponseTuningMethod) -> None: ...
    def setTd(self, double: float) -> None: ...
    def setTi(self, double: float) -> None: ...
    def setTransmitter(self, measurementDeviceInterface: neqsim.process.measurementdevice.MeasurementDeviceInterface) -> None: ...
    def setUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...

class ModelPredictiveController(neqsim.util.NamedBaseClass, ControllerDeviceInterface):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: typing.Union[java.lang.String, str]): ...
    def addQualityConstraint(self, qualityConstraint: 'ModelPredictiveController.QualityConstraint') -> None: ...
    @typing.overload
    def autoTune(self, double: float, double2: float) -> None: ...
    @typing.overload
    def autoTune(self, double: float, double2: float, boolean: bool) -> None: ...
    @typing.overload
    def autoTune(self) -> 'ModelPredictiveController.AutoTuneResult': ...
    @typing.overload
    def autoTune(self, list: java.util.List[float], list2: java.util.List[float], list3: java.util.List[float], autoTuneConfiguration: 'ModelPredictiveController.AutoTuneConfiguration') -> 'ModelPredictiveController.AutoTuneResult': ...
    @typing.overload
    def autoTune(self, autoTuneConfiguration: 'ModelPredictiveController.AutoTuneConfiguration') -> 'ModelPredictiveController.AutoTuneResult': ...
    def clearMovingHorizonHistory(self) -> None: ...
    def clearQualityConstraints(self) -> None: ...
    def configureControls(self, *string: typing.Union[java.lang.String, str]) -> None: ...
    def disableMovingHorizonEstimation(self) -> None: ...
    def enableMovingHorizonEstimation(self, int: int) -> None: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getCalcIdentifier(self) -> java.util.UUID: ...
    def getControlNames(self) -> java.util.List[java.lang.String]: ...
    @typing.overload
    def getControlValue(self, int: int) -> float: ...
    @typing.overload
    def getControlValue(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getControlVector(self) -> typing.MutableSequence[float]: ...
    def getControlWeight(self) -> float: ...
    def getControllerSetPoint(self) -> float: ...
    def getLastAppliedControl(self) -> float: ...
    def getLastMovingHorizonEstimate(self) -> 'ModelPredictiveController.MovingHorizonEstimate': ...
    def getLastSampleTime(self) -> float: ...
    def getLastSampledValue(self) -> float: ...
    def getMaxResponse(self) -> float: ...
    @typing.overload
    def getMeasuredValue(self) -> float: ...
    @typing.overload
    def getMeasuredValue(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getMinResponse(self) -> float: ...
    def getMoveWeight(self) -> float: ...
    def getMovingHorizonEstimationWindow(self) -> int: ...
    def getOutputWeight(self) -> float: ...
    def getPredictedQuality(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getPredictedTrajectory(self, int: int, double: float) -> typing.MutableSequence[float]: ...
    def getPredictionHorizon(self) -> int: ...
    def getProcessBias(self) -> float: ...
    def getProcessGain(self) -> float: ...
    def getResponse(self) -> float: ...
    def getTimeConstant(self) -> float: ...
    def getUnit(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def ingestPlantSample(self, double: float, double2: float) -> None: ...
    @typing.overload
    def ingestPlantSample(self, double: float, double2: float, double3: float) -> None: ...
    def isActive(self) -> bool: ...
    def isMovingHorizonEstimationEnabled(self) -> bool: ...
    def isReverseActing(self) -> bool: ...
    @typing.overload
    def runTransient(self, double: float, double2: float) -> None: ...
    @typing.overload
    def runTransient(self, double: float, double2: float, uUID: java.util.UUID) -> None: ...
    def setActive(self, boolean: bool) -> None: ...
    @typing.overload
    def setControlLimits(self, int: int, double: float, double2: float) -> None: ...
    @typing.overload
    def setControlLimits(self, string: typing.Union[java.lang.String, str], double: float, double2: float) -> None: ...
    @typing.overload
    def setControlMoveLimits(self, int: int, double: float, double2: float) -> None: ...
    @typing.overload
    def setControlMoveLimits(self, string: typing.Union[java.lang.String, str], double: float, double2: float) -> None: ...
    def setControlWeights(self, *double: float) -> None: ...
    def setControllerParameters(self, double: float, double2: float, double3: float) -> None: ...
    @typing.overload
    def setControllerSetPoint(self, double: float, string: typing.Union[java.lang.String, str]) -> None: ...
    @typing.overload
    def setControllerSetPoint(self, double: float) -> None: ...
    def setEnergyReference(self, double: float) -> None: ...
    def setEnergyReferenceVector(self, *double: float) -> None: ...
    def setInitialControlValues(self, *double: float) -> None: ...
    def setMoveLimits(self, double: float, double2: float) -> None: ...
    def setMoveWeights(self, *double: float) -> None: ...
    def setOutputLimits(self, double: float, double2: float) -> None: ...
    def setPredictionHorizon(self, int: int) -> None: ...
    def setPreferredControlValue(self, double: float) -> None: ...
    def setPreferredControlVector(self, *double: float) -> None: ...
    def setPrimaryControlIndex(self, int: int) -> None: ...
    def setProcessBias(self, double: float) -> None: ...
    @typing.overload
    def setProcessModel(self, double: float, double2: float) -> None: ...
    @typing.overload
    def setProcessModel(self, double: float, double2: float, double3: float) -> None: ...
    def setReverseActing(self, boolean: bool) -> None: ...
    def setTransmitter(self, measurementDeviceInterface: neqsim.process.measurementdevice.MeasurementDeviceInterface) -> None: ...
    def setUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def setWeights(self, double: float, double2: float, double3: float) -> None: ...
    def updateFeedConditions(self, map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]], double: float) -> None: ...
    def updateQualityMeasurement(self, string: typing.Union[java.lang.String, str], double: float) -> bool: ...
    def updateQualityMeasurements(self, map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]]) -> None: ...
    class AutoTuneConfiguration:
        @staticmethod
        def builder() -> 'ModelPredictiveController.AutoTuneConfiguration.Builder': ...
        def getClosedLoopTimeConstantRatio(self) -> float: ...
        def getControlWeightFactor(self) -> float: ...
        def getMaximumHorizon(self) -> int: ...
        def getMinimumHorizon(self) -> int: ...
        def getMoveWeightFactor(self) -> float: ...
        def getOutputWeight(self) -> float: ...
        def getPredictionHorizonMultiple(self) -> float: ...
        def getSampleTimeOverride(self) -> float: ...
        def isApplyImmediately(self) -> bool: ...
        class Builder:
            def applyImmediately(self, boolean: bool) -> 'ModelPredictiveController.AutoTuneConfiguration.Builder': ...
            def build(self) -> 'ModelPredictiveController.AutoTuneConfiguration': ...
            def closedLoopTimeConstantRatio(self, double: float) -> 'ModelPredictiveController.AutoTuneConfiguration.Builder': ...
            def controlWeightFactor(self, double: float) -> 'ModelPredictiveController.AutoTuneConfiguration.Builder': ...
            def defaults(self) -> 'ModelPredictiveController.AutoTuneConfiguration.Builder': ...
            def maximumHorizon(self, int: int) -> 'ModelPredictiveController.AutoTuneConfiguration.Builder': ...
            def minimumHorizon(self, int: int) -> 'ModelPredictiveController.AutoTuneConfiguration.Builder': ...
            def moveWeightFactor(self, double: float) -> 'ModelPredictiveController.AutoTuneConfiguration.Builder': ...
            def outputWeight(self, double: float) -> 'ModelPredictiveController.AutoTuneConfiguration.Builder': ...
            def predictionHorizonMultiple(self, double: float) -> 'ModelPredictiveController.AutoTuneConfiguration.Builder': ...
            def sampleTimeOverride(self, double: float) -> 'ModelPredictiveController.AutoTuneConfiguration.Builder': ...
    class AutoTuneResult:
        def getClosedLoopTimeConstant(self) -> float: ...
        def getControlWeight(self) -> float: ...
        def getMeanSquaredError(self) -> float: ...
        def getMoveWeight(self) -> float: ...
        def getOutputWeight(self) -> float: ...
        def getPredictionHorizon(self) -> int: ...
        def getProcessBias(self) -> float: ...
        def getProcessGain(self) -> float: ...
        def getSampleCount(self) -> int: ...
        def getSampleTime(self) -> float: ...
        def getTimeConstant(self) -> float: ...
        def isApplied(self) -> bool: ...
    class MovingHorizonEstimate:
        def getMeanSquaredError(self) -> float: ...
        def getProcessBias(self) -> float: ...
        def getProcessGain(self) -> float: ...
        def getSampleCount(self) -> int: ...
        def getTimeConstant(self) -> float: ...
    class QualityConstraint:
        @staticmethod
        def builder(string: typing.Union[java.lang.String, str]) -> 'ModelPredictiveController.QualityConstraint.Builder': ...
        class Builder:
            def build(self) -> 'ModelPredictiveController.QualityConstraint': ...
            def compositionSensitivities(self, map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]]) -> 'ModelPredictiveController.QualityConstraint.Builder': ...
            def compositionSensitivity(self, string: typing.Union[java.lang.String, str], double: float) -> 'ModelPredictiveController.QualityConstraint.Builder': ...
            def controlSensitivity(self, *double: float) -> 'ModelPredictiveController.QualityConstraint.Builder': ...
            def limit(self, double: float) -> 'ModelPredictiveController.QualityConstraint.Builder': ...
            def margin(self, double: float) -> 'ModelPredictiveController.QualityConstraint.Builder': ...
            def measurement(self, measurementDeviceInterface: neqsim.process.measurementdevice.MeasurementDeviceInterface) -> 'ModelPredictiveController.QualityConstraint.Builder': ...
            def rateSensitivity(self, double: float) -> 'ModelPredictiveController.QualityConstraint.Builder': ...
            def unit(self, string: typing.Union[java.lang.String, str]) -> 'ModelPredictiveController.QualityConstraint.Builder': ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("neqsim.process.controllerdevice")``.

    ControllerDeviceBaseClass: typing.Type[ControllerDeviceBaseClass]
    ControllerDeviceInterface: typing.Type[ControllerDeviceInterface]
    ControllerEvent: typing.Type[ControllerEvent]
    ModelPredictiveController: typing.Type[ModelPredictiveController]
    structure: neqsim.process.controllerdevice.structure.__module_protocol__
